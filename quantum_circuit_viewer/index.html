<html lang="en"><head>
  <meta charset="UTF-8">
  <title>Quantum Circuit Viewer</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    #canvasContainer { margin-top: 20px; }
    canvas { border: 1px solid #ccc; }
    #fitnessChartContainer { margin-top: 40px; width: 100%; overflow-x: auto; }
    #fitnessChart { min-width: 1200px; height: 500px; }
    .gate-palette {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .draggable-gate {
      width: 40px;
      height: 40px;
      border: 1px solid #888;
      border-radius: 6px;
      text-align: center;
      line-height: 40px;
      font-weight: bold;
      font-family: Arial;
      font-size: 14px;
      user-select: none;
      cursor: grab;
    }
    .gate-wire { background-color: #eee; color: #000; }
    .gate-H { background-color: #f88; color: #000; }
    .gate-T { background-color: #88f; color: #000; }
    .gate-Td { background-color: #4cf; color: #000; }
    .gate-X { background-color: #fff; color: #00f; border: 2px solid #00f; border-radius: 80%; }
    .gate-C { background-color: #fff; color: #00f; border: 2px solid #00f; border-radius: 80%; }

    .matrix td { padding: 4px; border: 1px solid #000; text-align: center; font-family: monospace; font-size:20px;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</head>
<body>
  <h2>Quantum Circuit Viewer</h2>

  <!-- 下拉式選單 -->
  <label for="FunctionName">Function Name：</label>
  <select id="FunctionName">
      <option value="sqrt(SWAP)">sqrt(SWAP)</option>
      <option value="HHL">HHL</option>
  </select>

  <label for="circuitDepth">depth 數：</label>
  <input type="number" id="circuitDepth" value="7" min="1" max="15" style="width: 50px;">
  <button onclick="setCircuitDepth()">套用</button>

  <div>
    <div style="display: inline-block; vertical-align: top;">
      <input type="file" id="fileInput">
      <div>
        <label for="genInput">Go to Generation:</label>
        <input type="number" id="genInput" min="1" style="width: 80px;">
        <button onclick="jumpToGeneration()">Go</button>
      </div>
      <div style="margin-top: 10px;">
        Gen.: 
        <input type="range" id="genSlider" min="1" max="10000" value="1" style="width: 450px;">
        <span id="genLabel">1</span>
      </div>
      <div>
        Fit.: <span id="fitnessValue">0.20943058495790511930323418710031546652317047119140625</span>
      </div>
      <div style="margin-top: 10px;">
        <label for="manualCircuitInput"><strong>輸入電路：</strong></label><br>
        <span style="font-size: 14px;">
          支援以下兩種格式，按「套用電路」以直接修改目前 generation 的電路：
          <ul style="margin-top: 4px; margin-bottom: 6px; padding-left: 20px;">
            <li><strong>格式 A</strong>：每行代表一個 qubit，gate 用空格分隔</li>
            <pre style="background:#f9f9f9; padding:4px;">
3 3 5 1 0 1 5 3 0 3 0 3
5 1 2 5 0 5 3 0 2 4 1 5
4 3 4 4 3 4 4 3 3 5 2 4</pre>

            <li><strong>格式 B</strong>：每個 qubit 放在一個 <code>[ ... ]</code> 括號中</li>
            <pre style="background:#f9f9f9; padding:4px;">[3 3 5 1 0 1 5 3 0 3 0 3] [5 1 2 5 0 5 3 0 2 4 1 5] [4 3 4 4 3 4 4 3 3 5 2 4]</pre>
          </ul>
        </span>
        <textarea id="manualCircuitInput" rows="4" cols="80" placeholder="請貼上格式 A 或 B 的電路 gate 編碼..."></textarea>
        <button onclick="applyManualCircuit()">套用電路</button>
      </div>
      <!-- ✅ Gate Palette -->
      <label><strong>拖曳電路：</strong></label><br>
      <div class="gate-palette">
        <div class="draggable-gate gate-wire" draggable="true" data-gate="0">W</div>
        <div class="draggable-gate gate-H" draggable="true" data-gate="1">H</div>
        <div class="draggable-gate gate-T" draggable="true" data-gate="2">T</div>
        <div class="draggable-gate gate-Td" draggable="true" data-gate="3">T†</div>
        <div class="draggable-gate gate-X" draggable="true" data-gate="4">⊕</div>
        <div class="draggable-gate gate-C" draggable="true" data-gate="5">●</div>
      </div>
    </div>
    <div style="display: inline-block; vertical-align: top; width: 50px;"></div>
    <div style="display: inline-block; vertical-align: top;">
        <div id="result"></div>
    </div>
  </div>
  <div>
    <div id="canvasContainer" style="display: inline-block; vertical-align: top;">
      <canvas id="circuitCanvas"></canvas>
    </div>
    <button onclick="clear_circuit()">清空</button>
    <button onclick="screenshot_onoff()">截圖</button>
    <div style="display: inline-block; vertical-align: top; margin-top: 20px;">
      <table id="matrix" class="matrix"></table>
    </div>
  </div>

  <div id="fitnessChartContainer">
    <canvas id="fitnessChart" style="box-sizing: border-box; display: block; height: 530px; width: 1246px;" width="1246" height="530"></canvas>
  </div>
  <div><br><br>a:last gen, d:next gen, w:last change, s:next change</div>

  <script>
    let M = document.getElementById("circuitDepth").value;
    let N = 2;

    M = parseInt(M);  // 確保轉成整數
    const canvas = document.getElementById("circuitCanvas");
    canvas.width = 60 + 60 * M;
    canvas.height = 50 * N + 50;

    let TargetArrat = [
        [1, 0, 0, 0],
        [0, math.complex(0.5, 0.5), math.complex(0.5, -0.5), 0],
        [0, math.complex(0.5, -0.5), math.complex(0.5, 0.5), 0],
        [0, 0, 0, 1],
    ];

    class DeferredCpx {
      constructor(val = math.complex(0, 0), hasSqrt2 = false) {
        this.real = math.complex(0, 0);
        this.real_sqrt2 = math.complex(0, 0);
        this.imag = math.complex(0, 0);
        this.imag_sqrt2 = math.complex(0, 0);

        if (hasSqrt2) {
          this.real_sqrt2 = math.complex(val.re, 0);
          this.imag_sqrt2 = math.complex(val.im, 0);
        } else {
          this.real = math.complex(val.re, 0);
          this.imag = math.complex(val.im, 0);
        }
      }

      add(other) {
        const r = new DeferredCpx();
        r.real = math.add(this.real, other.real);
        r.real_sqrt2 = math.add(this.real_sqrt2, other.real_sqrt2);
        r.imag = math.add(this.imag, other.imag);
        r.imag_sqrt2 = math.add(this.imag_sqrt2, other.imag_sqrt2);
        return r;
      }

      addInPlace(other) {
        this.real = math.add(this.real, other.real);
        this.real_sqrt2 = math.add(this.real_sqrt2, other.real_sqrt2);
        this.imag = math.add(this.imag, other.imag);
        this.imag_sqrt2 = math.add(this.imag_sqrt2, other.imag_sqrt2);
        return this;
      }

      multiply(other) {
        const r = new DeferredCpx();
        const half = 0.5;

        // real x real
        r.real = math.add(r.real, math.multiply(this.real, other.real));
        r.real_sqrt2 = math.add(r.real_sqrt2, math.multiply(this.real, other.real_sqrt2));
        r.real_sqrt2 = math.add(r.real_sqrt2, math.multiply(this.real_sqrt2, other.real));
        r.real = math.add(r.real, math.multiply(this.real_sqrt2, other.real_sqrt2).mul(half));

        // real x imag
        r.imag = math.add(r.imag, math.multiply(this.real, other.imag));
        r.imag_sqrt2 = math.add(r.imag_sqrt2, math.multiply(this.real, other.imag_sqrt2));
        r.imag_sqrt2 = math.add(r.imag_sqrt2, math.multiply(this.real_sqrt2, other.imag));
        r.imag = math.add(r.imag, math.multiply(this.real_sqrt2, other.imag_sqrt2).mul(half));

        // imag x real
        r.imag = math.add(r.imag, math.multiply(this.imag, other.real));
        r.imag_sqrt2 = math.add(r.imag_sqrt2, math.multiply(this.imag, other.real_sqrt2));
        r.imag_sqrt2 = math.add(r.imag_sqrt2, math.multiply(this.imag_sqrt2, other.real));
        r.imag = math.add(r.imag, math.multiply(this.imag_sqrt2, other.real_sqrt2).mul(half));

        // imag x imag
        r.real = math.subtract(r.real, math.multiply(this.imag, other.imag));
        r.real_sqrt2 = math.subtract(r.real_sqrt2, math.multiply(this.imag, other.imag_sqrt2));
        r.real_sqrt2 = math.subtract(r.real_sqrt2, math.multiply(this.imag_sqrt2, other.imag));
        r.real = math.subtract(r.real, math.multiply(this.imag_sqrt2, other.imag_sqrt2).mul(half));

        return r;
      }

      evaluate() {
        const sqrt2 = Math.SQRT2;
        return math.add(
          math.add(this.real, math.divide(this.real_sqrt2, sqrt2)),
          math.multiply(math.complex(0, 1),
            math.add(this.imag, math.divide(this.imag_sqrt2, sqrt2))
          )
        );
      }
    }
 
    // 監聽下拉選單改變事件
    document.getElementById("FunctionName").addEventListener("change", function() {
      const depthInput = document.getElementById("circuitDepth");

      if (this.value === "sqrt(SWAP)")
      {
        N = 2;
        M = 7;
        depthInput.value = M;

        TargetArrat = [
            [1, 0,                       0,                       0],
            [0, math.complex(0.5, 0.5),  math.complex(0.5, -0.5), 0],
            [0, math.complex(0.5, -0.5), math.complex(0.5, 0.5),  0],
            [0, 0,                       0,                       1],
        ];
        data = [{
          gen: 1,
          circuit: [[5, 1, 5, 2, 5, 1, 5],
                    [4, 2, 4, 3, 4, 0, 4]],
          fitness: 0
        }];

        gates_arrays = {};
        setGatesArray();
        const canvas = document.getElementById("circuitCanvas");
        canvas.width = 60 + 60 * M;      // 更新寬度（startX + stepX * depth）
        canvas.height = 50 * N + 50;     // 更新高度（每條線50px + 上下邊界）
        renderCircuit(1);
      }
      else if (this.value === "HHL")
      {
        N = 3;
        M = 12;
        depthInput.value = M;

        TargetArrat = [
            [ 0, 0,  0, math.complex(0, -1), 0, 0,  0, 0],
            [ 0, 0, -1, 0,                   0, 0,  0, 0],
            [ 0, 1,  0, 0,                   0, 0,  0, 0],
            [-1, 0,  0, 0,                   0, 0,  0, 0],
            [ 0, 0,  0, 0,                   1, 0,  0, 0],
            [ 0, 0,  0, 0,                   0, 1,  0, 0],
            [ 0, 0,  0, 0,                   0, 0, -1, 0],
            [ 0, 0,  0, 0,                   0, 0,  0, math.complex(0, 1)]
        ];
        data = [{
          gen: 1,
          circuit: [[0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],
                    [3, 5, 1, 5, 3, 3, 4, 0, 0, 4, 2, 2],
                    [3, 4, 2, 4, 3, 3, 5, 1, 4, 5, 2, 2]],
          fitness: 0
        }];

        gates_arrays = {};
        setGatesArray();
        const canvas = document.getElementById("circuitCanvas");
        canvas.width = 60 + 60 * M;
        canvas.height = 50 * N + 50;
        renderCircuit(1);
      }
        
    });
    
    function setCircuitDepth(){
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const m_ = document.getElementById("circuitDepth").value;
      if (m_ > d.circuit[0].length)
      {
        for (let i = d.circuit[0].length; i < m_; i++)
        {
          for (let j = 0; j < d.circuit.length; j++)
          {
            d.circuit[j].push(0);
          }
        }
      }

      // ⭐ 動態更新 canvas 寬度（每個 gate 寬度 60px，加上起始邊界）
      const canvas = document.getElementById("circuitCanvas");
      const newWidth = 60 + 60 * m_;  // startX + stepX * depth
      canvas.width = newWidth;

      renderCircuit(gen);
      console.log(d.circuit);
    }

    function clear_circuit()
    {
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      d0.circuit = JSON.parse(JSON.stringify(d.circuit));
      d0.fitness = JSON.parse(JSON.stringify(d.fitness));
      for (let i = 0; i < d.circuit.length; i++)
      {
        for (let j = 0; j < d.circuit[i].length; j++)
        {
          d0.circuit[i][j] = 0;
        }
      }
      renderCircuit(0);
      updateFitness(d0); // 即時更新 fitness
      d0_gen = gen;
    }
    
    let gates = [ "─","H","t","T","⊕","●" ];
    let gates_arrays = {};
    
    function setCnotArray() {
        let I = [[1,0],
                 [0,1]]
        let X = [[0,1],
                 [1,0]];
        let P0 = [[1,0],
                  [0,0]];
        let P1 = [[0,0],
                  [0,1]];
        let I_array = I;
        for (let n = 1; n < N; n++) {
            I_array = math.kron(I_array, I);
        }
        gates_arrays["I"] = I_array;

        for (let ctrl_ = 0; ctrl_ < N; ctrl_++) {
            for (let not_ = 0; not_ < N; not_++) {
                if (ctrl_ !== not_) {
                    let term0 = [[math.complex(1, 0)]]; // P0 控制項
                    let term1 = [[math.complex(1, 0)]]; // P1 控制項與 X 目標項

                    for (let k = 0; k < N; k++) {
                        if (k === ctrl_) {
                            term0 = math.kron(term0, P0);
                            term1 = math.kron(term1, P1);
                        } else if (k === not_) {
                            term0 = math.kron(term0, I);
                            term1 = math.kron(term1, X);
                        } else {
                            term0 = math.kron(term0, I);
                            term1 = math.kron(term1, I);
                        }
                    }

                    // cnot_array = term0 + term1
                    let cnot_array = [];
                    for (let i = 0; i < term0.length; i++) {
                        cnot_array[i] = [];
                        for (let j = 0; j < term0[i].length; j++) {
                            cnot_array[i][j] = math.add(term0[i][j], term1[i][j]);
                        }
                    }

                    let array_name = `CNOT(${ctrl_},${not_})`;
                    gates_arrays[array_name] = cnot_array;
                }
            }
        }
    }
    
    function setGatesArray() {
        setCnotArray();
        // 單閘 (非 ─, ⊕, ●) 的 tensor product gate array
        const gates_Matrix = [
            [[1, 0], [0, 1]],
            [[1/Math.sqrt(2), 1/Math.sqrt(2)],
             [1/Math.sqrt(2), -1/Math.sqrt(2)]],
            [[1, 0],
             [0, math.exp(math.complex(0, Math.PI / 4))]],
            [[1, 0],
             [0, math.exp(math.complex(0, -Math.PI / 4))]],
            [[1, 0], [0, 1]],
            [[1, 0], [0, 1]],
        ];

        for (let i = 0; i < gates.length; i++) {
            if (i !== 0 && i !== 4 && i !== 5) { // != "─" && != "⊕" && != "●"
                for (let j = 0; j < N; j++) {
                    let circuit_array;
                    for (let k = 0; k < N; k++) {
                        if (k === 0) {
                            circuit_array = (k === j) ? gates_Matrix[i] : gates_Matrix[0];
                        } else {
                            circuit_array = math.kron(circuit_array, (k === j) ? gates_Matrix[i] : gates_Matrix[0]);
                        }
                    }
                    let array_name = `${gates[i]}(${j})`;
                    gates_arrays[array_name] = circuit_array;

                }
            }
        }    

        // 所有可能的 depth 組合
        let set_c = [];
        for (let i = 0; i <= N; i++) {
            set_c.push([0]);
        }
        set_c[0][0] = -1;
 
        let total_depth = Math.pow(6, N);
        for (let i = 0; i < total_depth; i++) {
            set_c[0][0] += 1;

            let depth_gates = [];
            let ctrl_ = -1;
            let not_ = -1;
            let oneCNOT = true;

            for (let n = 0; n < N; n++) {
                if (set_c[n][0] > 5) {
                    set_c[n][0] = 0;
                    set_c[n + 1][0] += 1;
                }

                if (set_c[n][0] !== 4 && set_c[n][0] !== 5 && set_c[n][0] !== 0) {
                    let gate_name = `${gates[set_c[n][0]]}(${n})`;
                    depth_gates.push(gate_name);
                } else if (set_c[n][0] === 4) {
                    if (not_ === -1) {
                        not_ = n;
                    } else {
                        oneCNOT = false;
                    }
                } else if (set_c[n][0] === 5) {
                    if (ctrl_ === -1) {
                        ctrl_ = n;
                    } else {
                        oneCNOT = false;
                    }   
                }
            }

            if (((ctrl_ !== -1 && not_ !== -1) || (ctrl_ === -1 && not_ === -1)) && oneCNOT === true && depth_gates.length !== 0) {
                if (ctrl_ !== -1 && not_ !== -1) {
                    let cnot_name = `CNOT(${ctrl_},${not_})`;
                    depth_gates.push(cnot_name);
                }

                let depth_name = "";
                let depth_array = gates_arrays["I"];
                for (let x = 0; x < depth_gates.length; x++) {
                    depth_name += depth_gates[x];
                    depth_array = math.multiply(gates_arrays[depth_gates[x]], depth_array);
                }

                gates_arrays[depth_name] = depth_array;
            }
        }
    }

    function checkerDeferred(circuit) {
      let result = identityDeferred(N);

      for (let d = 0; d < circuit[0].length; d++) {
        // collect gate type per bit
        const gatesAtDepth = circuit.map(row => row[d]);
        let layerMatrix = identityDeferred(N);

        // handle single qubit gates
        for (let q = 0; q < N; q++) {
          const gid = gatesAtDepth[q];
          if (gid === 0 || gid >= 4) continue;  // ─, ⊕, ● skip
          const gate = getDeferredGate(gid);
          const applied = apply_single_qubit_gate_js(q, gate, N);
          layerMatrix = matmulDeferred(applied, layerMatrix);
        }

        // handle CNOTs
        for (let ctrl = 0; ctrl < N; ctrl++) {
          if (gatesAtDepth[ctrl] === 5) {
            for (let tgt = 0; tgt < N; tgt++) {
              if (gatesAtDepth[tgt] === 4) {
                const cnot = apply_cnot_js(ctrl, tgt, N);
                layerMatrix = matmulDeferred(cnot, layerMatrix);
              }
            }
          }
        }

        result = matmulDeferred(layerMatrix, result);
      }

      return result;
    }

    setGatesArray();

    var screenshot_ = false;
    let draggedGate = null;
    let data = [{
      gen: 1,
      circuit: [[5, 1, 5, 2, 5, 1, 5],
                [4, 2, 4, 3, 4, 0, 4]],
      fitness: 0
    }];
    let data0 = [{
      gen: 1,
      circuit: [[5, 1, 5, 2, 5, 1, 5],
                [4, 2, 4, 3, 4, 0, 4]],
      fitness: 0
    }];

    //let data = [{
    //  gen: 1,
    //  q0: [5, 1, 5, 2, 5, 1, 5],
    //  q1: [4, 2, 4, 3, 4, 0, 4],
    //  fitness: 0
    //}];

    const gateMap = ['empty', 'H', 'T', 'T†', 'X', 'C'];

    const ctx = canvas.getContext('2d');
    let fitnessChart;

    updateFitnessChart();
    renderCircuit(1);

    function screenshot_onoff() {
      let result_div = document.getElementById('result');
      result_div.innerHTML = "";
      if(screenshot_ === true)
      {
        screenshot_ = false;
      }
      else
      {
        screenshot_ = true;
        captureAndCrop();
      }
    }
    
    function captureAndCrop() {
      const target = document.getElementById("circuitCanvas");
      const canvasWidth = target.width;
      const canvasHeight = target.height;
      
      html2canvas(target).then(originalCanvas => {
        // 建立新 canvas 來存放裁切的內容
        const cropCanvas = document.createElement("canvas");
        const cropCtx = cropCanvas.getContext("2d");

        // 這裡設定你要裁切的區域
        const cropX = 15;   // 從左邊裁切 15px
        const cropY = 30;   // 從上方裁切 33px
        const cropWidth = canvasWidth - 30;
        const cropHeight = canvasHeight - 40;

        cropCanvas.width = cropWidth;
        cropCanvas.height = cropHeight;

        // 將原始 canvas 的部分內容畫到新 canvas 上
        cropCtx.drawImage(
          originalCanvas,
          cropX, cropY,          // 原圖要開始裁切的位置
          cropWidth, cropHeight, // 裁切的寬高
          0, 0,                   // 貼到新 canvas 的位置
          cropWidth, cropHeight  // 新 canvas 寬高
        );

        // 加到畫面上
        const result = document.getElementById("result");
        result.innerHTML = ''; // 清除舊圖
        result.appendChild(cropCanvas);
      });
    }

    // 更新矩陣顯示
    function updateMatrixDisplay(m) {
      const table = document.getElementById('matrix');
      table.innerHTML = '';
      //console.log(m);
      const size = m.size()[0];
      for (let i = 0; i < size; i++) {
        const row = document.createElement('tr');
        for (let j = 0; j < size; j++) {
          const cell = document.createElement('td');
          const v = m.get([i, j]);
          const re = math.round(math.re(v), 8);
          const im = math.round(math.im(v), 8);
          const reColor = (re === 0) ? '#ccc' : '#000';
          const imColor = (im === 0) ? '#ccc' : '#000';
//          cell.innerHTML = `<span style="color:${reColor}">${re.toFixed(8)}</span>` +
//                           `<span style="color:#000">${im >= 0 ? '+' : ''}</span>` +
//                           `<span style="color:${imColor}">${im.toFixed(8)}i</span>`;

          cell.innerHTML = `<span style="color:${reColor}">${re.toFixed(8)}</span>`;
          if(imColor === '#ccc')
          {
            cell.innerHTML += `<span style="color:#ccc">${im >= 0 ? '+' : ''}</span>`;
          }
          else
          {
            cell.innerHTML += `<span style="color:#000">${im >= 0 ? '+' : ''}</span>`;
          }
          cell.innerHTML += `<span style="color:${imColor}">${im.toFixed(8)}i</span>`;

          row.appendChild(cell);
        }
        table.appendChild(row);
      }
    }
  
    function circuitsAreEqual(a, b) {
      return JSON.stringify(a.circuit) === JSON.stringify(b.circuit);
    }

    function findPreviousChange(currentIndex) {
      for (let i = currentIndex - 1; i >= 0; i--) {
        if (!circuitsAreEqual(data[i], data[currentIndex])) return i;
      }
      return currentIndex;
    }
   
    function findNextChange(currentIndex) {
      for (let i = currentIndex + 1; i < data.length; i++) {
        if (!circuitsAreEqual(data[i], data[currentIndex])) return i;
      }
      return currentIndex;
    }

    document.addEventListener('keydown', function (event) {
      const slider = document.getElementById('genSlider');
      let current = parseInt(slider.value);
      const max = parseInt(slider.max);
      const min = parseInt(slider.min);

      if (event.key === 'a' && current > min) {
        slider.value = current - 1;
        slider.dispatchEvent(new Event('input'));
        d0_gen = 0;
      } else if (event.key === 'd' && current < max) {
        slider.value = current + 1;
        slider.dispatchEvent(new Event('input'));
        d0_gen = 0;
      } else if (event.key === 'w') {
        const target = findPreviousChange(current - 1) + 1;
        slider.value = target;
        slider.dispatchEvent(new Event('input'));
        d0_gen = 0;
      } else if (event.key === 's') {
        const target = findNextChange(current - 1) + 1;
        slider.value = target;
        slider.dispatchEvent(new Event('input'));
        d0_gen = 0;
      }
    });

    document.getElementById('fileInput').addEventListener('change', function(evt) {
      const file = evt.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        const lines = e.target.result.split('\n').filter(l => l.trim() !== '');
        data = [];

        for (let i = 0; i < lines.length; i += 2) {
          const genNumber = parseInt(lines[i]);
          const match = lines[i + 1].matchAll(/\[([^\]]+)\]/g);
          const circuit = [];
          for (const m of match) {
            circuit.push(m[1].trim().split(/\s+/).map(Number));
          }

          // 從最後一個中括號後的部分抓取 fitness 值
          const fitnessStr = lines[i + 1].replace(/\[[^\]]+\]/g, '').trim();
          const fitness = parseFloat(fitnessStr);

          data.push({ gen: genNumber, circuit, fitness });
        }

        document.getElementById('genSlider').max = data.length;
        updateFitnessChart();
        renderCircuit(1);
      };
      reader.readAsText(file);
    });

    document.getElementById('genSlider').addEventListener('input', function() {
      const gen = parseInt(this.value);
      document.getElementById('genLabel').innerText = gen;
      renderCircuit(gen);
      d0_gen = 0;
    });

    document.addEventListener('keydown', function (event) {
      const slider = document.getElementById('genSlider');
      let current = parseInt(slider.value);
      const max = parseInt(slider.max);
      const min = parseInt(slider.min);

      if (event.key === 'ArrowLeft') {
        if (current > min) {
          slider.value = current - 1;
          slider.dispatchEvent(new Event('input'));
          d0_gen = 0;
        }
      } else if (event.key === 'ArrowRight') {
        if (current < max) {
          slider.value = current + 1;
          slider.dispatchEvent(new Event('input'));
          d0_gen = 0;
        }
      }
    });

    // Allow dragging
    document.querySelectorAll('.draggable-gate').forEach(gate => {
      gate.addEventListener('dragstart', (e) => {
        draggedGate = e.target.dataset.gate;
      });
    });

    // Setup for future drop logic
    canvas.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    var d0_gen = 0;

    // 可以拖拉的程式碼
    canvas.addEventListener('drop', (e) => {
      e.preventDefault();
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }

      if (!d) return;

      const x = e.offsetX;
      const y = e.offsetY;

      const col = Math.round((x - 60) / 60);
      if (col < 0 || col >= d0.circuit[0].length) return;
      
      const row = Math.round((y - 50) / 50);
      if (row < 0 || row >= d0.circuit.length) return;

      const g = parseInt(draggedGate);

      // 清除原有 CNOT 結構（若存在）
      //if ((d.q0[col] === 5 && d.q1[col] === 4) || (d.q0[col] === 4 && d.q1[col] === 5)) {
      //  d.q0[col] = 0;
      //  d.q1[col] = 0;
      //}

      //if (g === 5) {
        // CNOT: determine control and target
      //  if (y < 75) {
      //    d.q0[col] = 4; // control
      //    d.q1[col] = 5; // target
      //  } else {
      //    d.q0[col] = 5; // target
      //    d.q1[col] = 4; // control
      //  }
      //} else {
      //  if (y < 75) {
      //    d.q0[col] = g;
          // 若另一 qubit 是 CNOT 的一部分，清除
      //    if (d.q1[col] === 4 || d.q1[col] === 5) d.q1[col] = 0;
      //  } else {
      //    d.q1[col] = g;
      //    if (d.q0[col] === 4 || d.q0[col] === 5) d.q0[col] = 0;
      //  }
      //}
      if (d0.circuit[row][col] === 4 || d0.circuit[row][col] === 5)
      {
        d0.circuit[row][col] = 0;
        for (let i = 0; i < d0.circuit.length; i++)
        {
          if (d0.circuit[i][col] === 4 || d0.circuit[i][col] === 5)
          {
            d0.circuit[i][col] = 0;
          }
        }
      }
      d0.circuit[row][col] = g;
      //console.log(d0.circuit);

      renderCircuit(0);
      updateFitness(d0); // 即時更新 fitness
    });

    function drawGate(x, y, label, type) {
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      if (type === 'H') {
        ctx.fillStyle = '#f88';
        ctx.fillRect(x - 15, y - 15, 30, 30);
        ctx.strokeRect(x - 15, y - 15, 30, 30);
      } else if (type === 'T' || type === 'T†') {
        ctx.fillStyle = (type === 'T') ? '#88f' : '#4cf';
        ctx.fillRect(x - 15, y - 15, 30, 30);
        ctx.strokeRect(x - 15, y - 15, 30, 30);
      } else if (type === 'X') {
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y - 8);
        ctx.lineTo(x, y + 8);
        ctx.moveTo(x - 8, y);
        ctx.lineTo(x + 8, y);
        ctx.stroke();
      } else if (type === 'C') {
        ctx.fillStyle = '#00f';
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
      } else if (type === 'X_') {
        ctx.globalAlpha = 0.5;   // 設定透明度 0.5
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y - 8);
        ctx.lineTo(x, y + 8);
        ctx.moveTo(x - 8, y);
        ctx.lineTo(x + 8, y);
        ctx.stroke();
        ctx.globalAlpha = 1.0; // ⭐ 還原透明度
      } else if (type === 'C_') {
        ctx.globalAlpha = 0.5;   // 設定透明度 0.5
        ctx.fillStyle = '#00f';
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        ctx.globalAlpha = 1.0; // ⭐ 還原透明度
      }

      if (['H', 'T', 'T†'].includes(type)) {
        ctx.fillStyle = '#000';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x, y);
      }
    }

    function updateFitness(d) {
      // ⬇️ 使用 deferred gate 符號運算版本
      const deferredMat = checkerDeferred(d.circuit); // 回傳 DeferredMatrix

      // ⬇️ 將 DeferredMatrix 轉換為數值矩陣（complex[][]）
      const size = deferredMat.length;
      const mat = math.matrix(
        deferredMat.map(row => row.map(cell => cell.evaluate()))
      );
      
      // ✅ 顯示矩陣
      updateMatrixDisplay(mat);
      if(screenshot_ === true)
      {
        captureAndCrop();
      }

      const prod = math.multiply(math.conj(math.transpose(mat)), TargetArrat);
      const num = math.abs(math.trace(prod));
      const dem = prod.size()[0];
      const fitness = 1 - num / dem;
      document.getElementById('fitnessValue').innerText = fitness.toFixed(53);
    }

    function updateArray(d) {
      // ✅ 使用符號矩陣方式計算整個電路
      const deferredMat = checkerDeferred(d.circuit); // 回傳 DeferredMatrix

      // ✅ 將 DeferredMatrix 轉為 math.js 的複數矩陣格式（evaluate）
      const mat = math.matrix(
        deferredMat.map(row => row.map(cell => cell.evaluate()))
      );

      updateMatrixDisplay(mat);  // 顯示矩陣
      if (screenshot_ === true) {
        captureAndCrop();
      }
    }

    function renderCircuit(gen) {
      //const d = data.find(item => item.gen === gen);
      let d;
      if (gen === 0)
      {
        d = data0.find(item => item.gen === 1);
      }
      else
      {
        d = data.find(item => item.gen === gen);
      }

      if (!d) return;

      document.getElementById('fitnessValue').innerText = d.fitness.toFixed(53);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const startX = 60;
      const stepX = 60;
      //const q0Y = 50;
      //const q1Y = 100;
      let qY = [];

      ctx.strokeStyle = '#bbb';
      ctx.lineWidth = 2;
      ctx.beginPath();

      //ctx.moveTo(startX - 40, q0Y);
      //ctx.lineTo(startX + d.q0.length * stepX, q0Y);
      //ctx.moveTo(startX - 40, q1Y);
      //ctx.lineTo(startX + d.q1.length * stepX, q1Y);
      for (let i = 0; i < d.circuit.length; i++)
      {
        qY.push((i + 1) * 50);
        ctx.moveTo(startX - 40, qY[i]);
        ctx.lineTo(startX + d.circuit[0].length * stepX, qY[i]);
      };

      ctx.stroke();

      for (let i = 0; i < d.circuit[0].length; i++) {
        const x = startX + i * stepX;
        let ctrl_ = -1;
        let not_ = -1;
        for (let j = 0; j < d.circuit.length; j++) {
          if(gateMap[d.circuit[j][i]] === "C")
          {
            ctrl_ = j;
            drawGate(x, qY[ctrl_], '', 'C_');
          }
          else if(gateMap[d.circuit[j][i]] === "X")
          {
            not_ = j;
            drawGate(x, qY[not_], '', 'X_');
          }
          else if(gateMap[d.circuit[j][i]] !== 'empty')
          {
            drawGate(x, qY[j], gateMap[d.circuit[j][i]], gateMap[d.circuit[j][i]]);
          }
        }
        if(ctrl_ !== -1 && not_ !== -1)
        {
          drawGate(x, qY[not_], '', 'X');
          drawGate(x, qY[ctrl_], '', 'C');
          ctx.beginPath();
          ctx.moveTo(x, qY[not_]);
          ctx.lineTo(x, qY[ctrl_]);
          ctx.stroke();
        }
      }

      const gen_ = parseInt(document.getElementById('genSlider').value);
      const d_ = data.find(item => item.gen === gen_);
      updateArray(d_);
    }

    function updateFitnessChart() {
      const ctxChart = document.getElementById('fitnessChart').getContext('2d');
      const labels = data.map(d => d.gen);
      const values = data.map(d => d.fitness);

      if (fitnessChart) fitnessChart.destroy();
      fitnessChart = new Chart(ctxChart, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Fitness over Generations',
            data: values,
            borderColor: 'rgba(0, 123, 255, 1)',
            backgroundColor: 'rgba(0, 123, 255, 0.1)',
            pointRadius: 3,
            pointHoverRadius: 5,
            borderWidth: 2,
            fill: true,
            tension: 0.2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: {
                display: true,
                text: 'Generation'
              },
              ticks: {
                maxTicksLimit: 20,
                callback: function(value, index, ticks) {
                  if (index === 0 || index === ticks.length - 1 || index % Math.ceil(ticks.length / 20) === 0) {
                    return this.getLabelForValue(value);
                  }
                  return '';
                }
              }
            },
            y: {
              title: {
                display: true,
                text: 'Fitness'
              },
              beginAtZero: true
            }
          },
          plugins: {
            legend: {
              display: true,
              labels: {
                font: { size: 14 }
              }
            },
            tooltip: {
              animation: false,
              callbacks: {
                label: ctx => `Fitness: ${ctx.parsed.y.toFixed(53)}`
              }
            }
          }
        }
      });
    }

    function jumpToGeneration() {
      const input = document.getElementById('genInput');
      const slider = document.getElementById('genSlider');
      const max = parseInt(slider.max);
      const min = parseInt(slider.min);
      const value = parseInt(input.value);
      d0_gen = 0;

      if (!isNaN(value) && value >= min && value <= max) {
        slider.value = value;
        slider.dispatchEvent(new Event('input'));
      } else {
        alert(`Please enter a number between ${min} and ${max}`);
      }
    }
  
    function identityDeferred(n) {
      const size = 1 << n;
      const I = Array(size).fill(0).map(() =>
        Array(size).fill().map(() => new DeferredCpx())
      );
      for (let i = 0; i < size; i++) {
        I[i][i] = new DeferredCpx(math.complex(1, 0), false);
      }
      return I;
    }

    function kronDeferred(A, B) {
      const r1 = A.length, c1 = A[0].length;
      const r2 = B.length, c2 = B[0].length;
      const result = Array(r1 * r2).fill(0).map(() =>
        Array(c1 * c2).fill().map(() => new DeferredCpx())
      );
      for (let i = 0; i < r1; i++)
        for (let j = 0; j < c1; j++)
          for (let k = 0; k < r2; k++)
            for (let l = 0; l < c2; l++)
              result[i * r2 + k][j * c2 + l] = A[i][j].multiply(B[k][l]);
      return result;
    }

    function matmulDeferred(A, B) {
      const n = A.length, m = B[0].length, p = A[0].length;
      const result = Array(n).fill(0).map(() =>
        Array(m).fill().map(() => new DeferredCpx())
      );
      for (let i = 0; i < n; i++)
        for (let k = 0; k < p; k++)
          for (let j = 0; j < m; j++)
            result[i][j] = result[i][j].add(A[i][k].multiply(B[k][j]));
      return result;
    }
  
    function getDeferredGate(id) {
      const I = [
        [new DeferredCpx(math.complex(1, 0)), new DeferredCpx()],
        [new DeferredCpx(), new DeferredCpx(math.complex(1, 0))]
      ];
      if (id === 0) return I;

      if (id === 1) return [
        [new DeferredCpx(math.complex(1, 0), true), new DeferredCpx(math.complex(1, 0), true)],
        [new DeferredCpx(math.complex(1, 0), true), new DeferredCpx(math.complex(-1, 0), true)]
      ];

      if (id === 2) return [
        [new DeferredCpx(math.complex(1, 0)), new DeferredCpx()],
        [new DeferredCpx(), new DeferredCpx(math.complex(1, 1), true)]
      ];

      if (id === 3) return [
        [new DeferredCpx(math.complex(1, 0)), new DeferredCpx()],
        [new DeferredCpx(), new DeferredCpx(math.complex(1, -1), true)]
      ];

      throw new Error("Unknown gate id: " + id);
    }
  
    function apply_single_qubit_gate_js(target, gate, total_bits) {
      let result = (target === 0) ? gate : getDeferredGate(0); // I
      for (let i = 1; i < total_bits; i++) {
        const g = (i === target) ? gate : getDeferredGate(0);
        result = kronDeferred(result, g);
      }
      return result;
    }
  
    function apply_cnot_js(control, target, total_bits) {
      const dim = 1 << total_bits;
      const mat = Array(dim).fill().map(() =>
        Array(dim).fill().map(() => new DeferredCpx())
      );

      for (let i = 0; i < dim; i++) {
        const b_ctrl = (i >> (total_bits - 1 - control)) & 1;
        const flip = (b_ctrl) ? (i ^ (1 << (total_bits - 1 - target))) : i;
        mat[flip][i] = new DeferredCpx(math.complex(1, 0));
      }

      return mat;
    }
  
    function applyManualCircuit() {
      const input = document.getElementById("manualCircuitInput").value.trim();
      if (!input) return alert("請輸入電路內容");

      const gen = parseInt(document.getElementById("genSlider").value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      d0_gen = gen;
      if (!d) return alert("無對應 generation");

      let newCircuit = [];

      // ✅ 格式 B: 偵測是否為 [ ... ] [ ... ] 格式
      if (input.includes("[") && input.includes("]")) {
        const matches = [...input.matchAll(/\[([^\]]+)\]/g)];
        if (matches.length !== d.circuit.length) {
          return alert(`括號數量 (${matches.length}) 不符合 qubit 數 (${d.circuit.length})`);
        }

        for (let i = 0; i < matches.length; i++) {
          const rowStr = matches[i][1];
          const row = rowStr.trim().split(/\s+/).map(Number);
          if (row.length !== d.circuit[0].length) {
            return alert(`第 ${i + 1} 行長度 (${row.length}) 不符合 depth (${d.circuit[0].length})`);
          }
          newCircuit.push(row);
        }
      }
      // ✅ 格式 A: 每行一個 qubit
      else {
        const lines = input.split('\n').map(line => line.trim()).filter(line => line !== "");
        if (lines.length !== d.circuit.length) {
          return alert(`輸入行數 (${lines.length}) 不符合 qubit 數 (${d.circuit.length})`);
        }

        for (let i = 0; i < lines.length; i++) {
          const row = lines[i].split(/\s+/).map(Number);
          if (row.length !== d.circuit[0].length) {
            return alert(`第 ${i + 1} 行長度 (${row.length}) 不符合 depth (${d.circuit[0].length})`);
          }
          newCircuit.push(row);
        }
      }

      // ✅ 套用電路並重新 render
      d0.circuit = newCircuit;
      renderCircuit(0);
      updateFitness(d0);
    }
  </script>


</body></html>