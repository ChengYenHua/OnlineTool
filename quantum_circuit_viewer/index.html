<html lang="en"><head>
  <meta charset="UTF-8">
  <title>Quantum Circuit Viewer</title>
  <style>
    html { overflow-y: scroll; /* 始終保留垂直捲軸空間 */}
    body { font-family: 'Segoe UI', sans-serif; padding: 30px; max-width: 1000px; margin: auto; background: #f8f9fa; color: #333;}
    #canvasContainer { margin-top: 20px; background-color: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 12px rgba(0,0,0,0.1);}
    canvas { border: 1px solid #ccc; }
    #fitnessChartContainer {width: 98%; height: 98%; overflow-x: auto;}
    #fitnessChart { width: 100%;}
    .gate-palette {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .draggable-gate {
      width: 40px;
      height: 40px;
      border: 1px solid #888;
      border-radius: 6px;
      text-align: center;
      line-height: 40px;
      font-weight: bold;
      font-family: Arial;
      font-size: 14px;
      user-select: none;
      cursor: grab;
    }
    .gate-wire { background-color: #eee; color: #000; }
    .gate-H { background-color: #f88; color: #000; }
    .gate-T { background-color: #88f; color: #000; }
    .gate-Td { background-color: #4cf; color: #000; }
    .gate-X { background-color: #fff; color: #00f; border: 2px solid #00f; border-radius: 80%; }
    .gate-C { background-color: #fff; color: #00f; border: 2px solid #00f; border-radius: 80%; }

    .matrix td {
      padding: 8px;
      border: 1px solid #000;
      text-align: center;
      vertical-align: middle;
      font-family: monospace;
      font-size: 20px;
      height: 50px;
      width: 100px;
    }
    .feature-button {
      display: inline-block;
      padding: 10px 20px;
      margin: 0 8px;
      border-radius: 6px;
      background-color: #BFC2CB;
      color: white;
      font-size: 14px;
      font-weight: 600;
      font-family: "Segoe UI", sans-serif;
      cursor: pointer;
      border: 1px solid #8E9BAE;
      transition: background-color 0.3s, transform 0.2s;
    }

    .feature-button:hover {
      background-color: #DCDDDF; /* hover 為較淺藍 */
      transform: translateY(-1px);
    }

    .feature-button.active {
      background-color: #F4BAAF; /* active 為墨黑藍 */
      border-color: #CA774B;
    }
    select, input[type="number"], textarea {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #ccc;
      font-size: 14px;
      margin-right: 10px;
    }
    button {
      padding: 6px 12px;
      border-radius: 6px;
      background-color: #28a745;
      color: white;
      font-weight: bold;
      border: none;
      cursor: pointer;
    }
    button:hover {
      background-color: #218838;
    }

    .tooltip-container {
      position: relative;
      display: inline-block;
      margin-left: 10px;
    }

    .tooltip-button {
      background-color: #6c757d;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
    }

    .tooltip-box {
      visibility: hidden;
      width: 450px;
      background-color: white;
      color: black;
      text-align: left;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0px 4px 8px rgba(0,0,0,0.2);
      position: absolute;
      z-index: 10;
      top: 35px;
      left: 0;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.4;
      white-space: pre;
    }

    .tooltip-container:hover .tooltip-box {
      visibility: visible;
    }
    .tooltip-button:hover {
    background-color: #eb504b;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
</head>
<body>
  <h2>Quantum Circuit Viewer</h2>

  <div class="feature-button-container">
    <div class="feature-button active" data-tab="function">Function Viewer</div>
    <div class="feature-button" data-tab="editor">Circuit Editor</div>
    <div class="feature-button" data-tab="analyzer">Dynamic Analysis</div>
  </div>
  <!-- 下拉式選單 -->
  <div style="margin-top: 20px;">
    <label for="FunctionName"><strong>Target Function:</strong></label>
    <select id="FunctionName">
        <option value="sqrt(SWAP)">sqrt(SWAP)</option>
        <option value="ctrlS">ctrl-S</option>
        <option value="HHL">HHL</option>
        <option value="HHL_global_phase">HHL_global phase(-1)</option>
        <option value="Toffoli">Toffoli</option>
        <option value="Peres">Peres</option>
        <option value="TOFPN">TOF-PN</option>
        <option value="OR">OR</option>
        <option value="Fredkin">Fredkin</option>
        <option value="Permutation">Permutation</option>
    </select>
  
    <label for="circuitDepth"><strong>Depth Number：</strong></label>
    <input type="number" id="circuitDepth" value="7" min="1" max="100" style="width: 70px;">
    <button onclick="setCircuitDepth()">Apply</button>
  </div>

  <div id="input_file" style="margin-top: 10px;">
    <label><strong>Input File:</strong></label>
    <div class="tooltip-container">
      <button class="tooltip-button">Help</button>
      <div class="tooltip-box">
  <b>Supported format:</b> (0:wire, 1:H, 2:T, 3:Tdg, 4:not, 5:ctrl)
  <b>Format for each generation:</b>
  - The first line is the generation number (gen)
  - The second line contains:
    • Each qubit enclosed in [ ... ]
    • Followed by the fitness value

  ✔️ You can input multiple generations.
  ✔️ Repeat the same format block for each generation.

  <b>Example:</b>
  1
  [5 1 5 2 5 1 5] [4 2 4 3 4 0 4] 0.000000...
  2
  [5 1 5 2 5 1 5] [4 0 4 3 4 0 4] 0.076120...
  3
  [5 1 5 2 5 1 5] [4 0 4 0 4 0 4] 0.146446...

  <b>Keyboard shortcut:</b>
  <b>A</b>:last gen, <b>D</b>:next gen, <b>W</b>:last change, <b>S</b>:next change
      </div>
    </div>

    <div style="margin-top: 10px;">
      <input type="file" id="fileInput">
      <label for="genInput">Go to Generation:</label>
        <input type="number" id="genInput" min="1" style="width: 80px;">
        <button onclick="jumpToGeneration()">Go</button>
    </div>

    <div style="margin-top: 10px;">
      Gen.: 
      <input type="range" id="genSlider" min="1" max="10000" value="1" style="width: 450px;">
      <span id="genLabel">1</span>
    </div>
  </div>

  <div id="input_circuit_n" style="margin-top: 10px;">
    <div style="display: flex; align-items: center;">
      <label for="manualCircuitInput"><strong>Manual Circuit Input:</strong></label>
    <div class="tooltip-container">
      <button id="input_circuit_n_" class="tooltip-button" style="margin-top: 5px;">Help</button>
      <div class="tooltip-box">
  <b>Supported formats:</b> (0:wire, 1:H, 2:T, 3:Tdg, 4:not, 5:ctrl)
  <b>Format A:</b> One row per qubit, gates separated by spaces.
  <b>Example:</b><div id="InputTypeA" style="margin-left: 14px; white-space: pre-wrap; word-break: break-word;">5 1 5 2 5 1 5
4 2 4 3 4 0 4</div>
  <b>Format B:</b> Each qubit enclosed in [ ... ].
  <b>Example:</b><div id="InputTypeB" style="margin-left: 14px; white-space: pre-wrap; word-break: break-word;">[5 1 5 2 5 1 5] [4 2 4 3 4 0 4]</div>
        </div>
      </div>
    </div>

    <div style="display: flex; margin-top: 10px;">
      <textarea id="manualCircuitInput" rows="4" cols="55" placeholder="Paste circuit gate encoding in Format A or B..."></textarea>
      <button onclick="applyManualCircuit()">Apply</button>
    </div>
  </div>

  <div style="display: inline-block; vertical-align: top; margin-top: 10px;">
    <label><strong>Circuit Diagram:</strong></label>
    <div class="tooltip-container">
      <button id="input_circuit_n_" class="tooltip-button" style="margin-top: 5px;">Help</button>
      <div class="tooltip-box">
  <b>How to change circuit:?</b><br>
  <b>drag gate:</b> Move gate to other place.
  <b>mouse wheel:</b> Change gate.
  <b>double click:</b> Remove one gate.
  <b>click << button:</b> Push the circuit left.
  <b>click >> button:</b> Push the circuit right.
  <b>click Clear button:</b> Remove all gate.
  <b>click Copy:</b> Copy circuit to clipboard. 
      </div>
    </div>

    <div id="canvasContainer" style="margin-top: 10px;">
      <div  style="display: inline-block; vertical-align: top;">
        <canvas id="circuitCanvas"></canvas>
      </div>
      <div style="display: inline-flex; flex-direction: column; gap: 8px; margin-left: 10px; vertical-align: top;">
        <div style="display: flex; gap: 8px;">
          <button style="width: 60px;" onclick="push_left()"><<</button>
          <button style="width: 60px;" onclick="push_right()">>></button>
        </div>
        
        <div style="display: flex; gap: 8px;">
          <button style="width: 60px;" onclick="clear_circuit()">Clear</button>
          <button style="width: 60px;" onclick="copy_circuit()">Copy</button>
        </div>
      </div>
    </div>
  </div>

  <div id="HS_fitness" style="margin-top: 10px;">
    <div>
      <strong>Circuit Fitness:</strong>
      <span style="font-size: 12px; color: #777;">(1 − ⟨U, V⟩<sub>HS</sub>)</span>
    </div>
    <div style="margin-top: 10px;">
      <span title="Full value: 0.00000000000000000000000000000000000000000000000000000">
        <span id="fitnessValueShort">0.000000</span>
      </span>
    </div>
  </div>

  <div id="modify_mode" style="margin-top: 10px;">
    <!-- ✅ Gate Palette -->
    <label><strong>Modify circuit: (drag a gate below to the circuit area above)</strong></label><br>
    <div id="put_gate" class="gate-palette" style="margin-top: 10px;">
      <div class="draggable-gate gate-wire" draggable="true" data-gate="0">W</div>
      <div class="draggable-gate gate-H" draggable="true" data-gate="1">H</div>
      <div class="draggable-gate gate-T" draggable="true" data-gate="2">T</div>
      <div class="draggable-gate gate-Td" draggable="true" data-gate="3">T†</div>
      <div class="draggable-gate gate-X" draggable="true" data-gate="4">⊕</div>
      <div class="draggable-gate gate-C" draggable="true" data-gate="5">●</div>
    </div>
  </div>

  <div id="matrix_show" style="margin-top: 10px;">
       <label><strong>Circuit Matrix:</strong></label>

    <button onclick="captureMatrix()" style="margin-top: 10px; margin-left: 10px;">Download Matrix</button><br>

    <div style="display: inline-block; vertical-align: top; margin-top: 10px;">
      <table id="matrix" class="matrix"></table>
    </div>
  </div>

  <div id="fitnessChartContainer" style= "margin-top: 10px;">
    <label><strong>Line Scatter Plot:</strong></label><br>

    <div id="fitnessChart" style= "margin-top: 10px; width: 95%;"></div>
  </div>

  <script>


    let M = document.getElementById("circuitDepth").value;
    let N = 2;

    M = parseInt(M);  // 確保轉成整數
    const canvas = document.getElementById("circuitCanvas");
    // 定義 padding 與 spacing
    const leftPadding = 50;
    const rightPadding = 50;
    const topPadding = 20;
    const bottomPadding = 20;
    const gateWidth = 50;
    const qubitSpacing = 50;

          let gates = [ "─","H","t","T","⊕","●" ];
          let gates_arrays = {};

    // 設定 canvas 尺寸（左右對稱，上下空白合適）
    canvas.width = leftPadding + M * gateWidth + rightPadding;
    canvas.height = topPadding + (N - 1) * qubitSpacing + bottomPadding;

          // 宣告變數來記錄滑鼠位置
          let mouseDownPos = null;
          let mouseUpPos = null;

    let TargetArrat = [
        [1, 0, 0, 0],
        [0, math.complex(0.5, 0.5), math.complex(0.5, -0.5), 0],
        [0, math.complex(0.5, -0.5), math.complex(0.5, 0.5), 0],
        [0, 0, 0, 1],
    ];

    class DeferredCpx {
      constructor(val = math.complex(0, 0), hasSqrt2 = false) {
        this.real = math.complex(0, 0);
        this.real_sqrt2 = math.complex(0, 0);
        this.imag = math.complex(0, 0);
        this.imag_sqrt2 = math.complex(0, 0);

        if (hasSqrt2) {
          this.real_sqrt2 = math.complex(val.re, 0);
          this.imag_sqrt2 = math.complex(val.im, 0);
        } else {
          this.real = math.complex(val.re, 0);
          this.imag = math.complex(val.im, 0);
        }
      }

      add(other) {
        const r = new DeferredCpx();
        r.real = math.add(this.real, other.real);
        r.real_sqrt2 = math.add(this.real_sqrt2, other.real_sqrt2);
        r.imag = math.add(this.imag, other.imag);
        r.imag_sqrt2 = math.add(this.imag_sqrt2, other.imag_sqrt2);
        return r;
      }

      addInPlace(other) {
        this.real = math.add(this.real, other.real);
        this.real_sqrt2 = math.add(this.real_sqrt2, other.real_sqrt2);
        this.imag = math.add(this.imag, other.imag);
        this.imag_sqrt2 = math.add(this.imag_sqrt2, other.imag_sqrt2);
        return this;
      }

      multiply(other) {
        const r = new DeferredCpx();
        const half = 0.5;

        // real x real
        r.real = math.add(r.real, math.multiply(this.real, other.real));
        r.real_sqrt2 = math.add(r.real_sqrt2, math.multiply(this.real, other.real_sqrt2));
        r.real_sqrt2 = math.add(r.real_sqrt2, math.multiply(this.real_sqrt2, other.real));
        r.real = math.add(r.real, math.multiply(this.real_sqrt2, other.real_sqrt2).mul(half));

        // real x imag
        r.imag = math.add(r.imag, math.multiply(this.real, other.imag));
        r.imag_sqrt2 = math.add(r.imag_sqrt2, math.multiply(this.real, other.imag_sqrt2));
        r.imag_sqrt2 = math.add(r.imag_sqrt2, math.multiply(this.real_sqrt2, other.imag));
        r.imag = math.add(r.imag, math.multiply(this.real_sqrt2, other.imag_sqrt2).mul(half));

        // imag x real
        r.imag = math.add(r.imag, math.multiply(this.imag, other.real));
        r.imag_sqrt2 = math.add(r.imag_sqrt2, math.multiply(this.imag, other.real_sqrt2));
        r.imag_sqrt2 = math.add(r.imag_sqrt2, math.multiply(this.imag_sqrt2, other.real));
        r.imag = math.add(r.imag, math.multiply(this.imag_sqrt2, other.real_sqrt2).mul(half));

        // imag x imag
        r.real = math.subtract(r.real, math.multiply(this.imag, other.imag));
        r.real_sqrt2 = math.subtract(r.real_sqrt2, math.multiply(this.imag, other.imag_sqrt2));
        r.real_sqrt2 = math.subtract(r.real_sqrt2, math.multiply(this.imag_sqrt2, other.imag));
        r.real = math.subtract(r.real, math.multiply(this.imag_sqrt2, other.imag_sqrt2).mul(half));

        return r;
      }

      evaluate() {
        const sqrt2 = Math.SQRT2;
        return math.add(
          math.add(this.real, math.divide(this.real_sqrt2, sqrt2)),
          math.multiply(math.complex(0, 1),
            math.add(this.imag, math.divide(this.imag_sqrt2, sqrt2))
          )
        );
      }
    }
        
    function setCircuitDepth(){
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      const m_ = document.getElementById("circuitDepth").value;
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }
      if (m_ > d0.circuit[0].length)
      {
        for (let i = d0.circuit[0].length; i < m_; i++)
        {
          for (let j = 0; j < d0.circuit.length; j++)
          {
            d0.circuit[j].push(0);
          }
        }
      }

      // ⭐ 動態更新 canvas 寬度（每個 gate 寬度 60px，加上起始邊界）
      const canvas = document.getElementById("circuitCanvas");
      const newWidth = leftPadding + m_ * gateWidth + rightPadding;
      canvas.width = newWidth;

      renderCircuit(0);
      //console.log(d.circuit);
    }

    function clear_circuit()
    {
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      //d0.circuit = JSON.parse(JSON.stringify(d.circuit));
      //d0.fitness = JSON.parse(JSON.stringify(d.fitness));
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }
      for (let i = 0; i < d0.circuit.length; i++)
      {
        for (let j = 0; j < d0.circuit[i].length; j++)
        {
          d0.circuit[i][j] = 0;
        }
      }
      renderCircuit(0);
      updateFitness(d0); // 即時更新 fitness
      d0_gen = gen;
    }

    function push_left()
    {
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      //d0.circuit = JSON.parse(JSON.stringify(d.circuit));
      //d0.fitness = JSON.parse(JSON.stringify(d.fitness));
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }
      
      for (let j = 0; j < d0.circuit[0].length; j++)
      {
        for (let i = 0; i < d0.circuit.length; i++)
        {
          if (d0.circuit[i][j] === 0)
          {
            for (let k = j; k < d0.circuit[i].length; k++)
            {
              if (d0.circuit[i][k] !== 0 && k !== j)
              {
                if (d0.circuit[i][k] !== 4 && d0.circuit[i][k] !== 5)
                {
                  d0.circuit[i][j] = d0.circuit[i][k];
                  d0.circuit[i][k] = 0;
                  //console.log(j,k);
                  //console.log(d0.circuit[i][j], d0.circuit[i][k]);
                  break;
                }
                else
                {
                  let ctrl_not = -1
                  for (let l = 0; l < d0.circuit.length; l++)
                  {
                    if ((d0.circuit[l][k] === 4 || d0.circuit[l][k] === 5) && l !== i)
                    {
                      ctrl_not = l;
                      break;
                    }
                  }
                  let can_push = 1;
                  for (let l = j; l < k; l++)
                  {
                    if (d0.circuit[ctrl_not][l] !== 0)
                    {
                      can_push = 0;
                      break;
                    }
                  }
                  if (can_push === 1)
                  {
                    d0.circuit[i][j] = d0.circuit[i][k];
                    d0.circuit[i][k] = 0;
                    d0.circuit[ctrl_not][j] = d0.circuit[ctrl_not][k];
                    d0.circuit[ctrl_not][k] = 0;
                    //console.log(j,k);
                    //console.log(d0.circuit[i][j], d0.circuit[i][k]);
                    break;
                  }
                  else
                  {
                    break;
                  }
                }
              }
            }
          }
          //console.log("-----");
        }
      }
      
      renderCircuit(0);
      updateFitness(d0); // 即時更新 fitness
      d0_gen = gen;
    }

    function push_right()
    {
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      //d0.circuit = JSON.parse(JSON.stringify(d.circuit));
      //d0.fitness = JSON.parse(JSON.stringify(d.fitness));
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }
      
      for (let j = d0.circuit[0].length - 1; j > -1; j--)
      {
        for (let i = 0; i < d0.circuit.length; i++)
        {
          if (d0.circuit[i][j] === 0)
          {
            for (let k = j; k > -1; k--)
            {
              if (d0.circuit[i][k] !== 0 && k !== j)
              {
                if (d0.circuit[i][k] !== 4 && d0.circuit[i][k] !== 5)
                {
                  d0.circuit[i][j] = d0.circuit[i][k];
                  d0.circuit[i][k] = 0;
                  //console.log(j,k);
                  //console.log(d0.circuit[i][j], d0.circuit[i][k]);
                  break;
                }
                else
                {
                  let ctrl_not = -1
                  for (let l = 0; l < d0.circuit.length; l++)
                  {
                    if ((d0.circuit[l][k] === 4 || d0.circuit[l][k] === 5) && l !== i)
                    {
                      ctrl_not = l;
                      break;
                    }
                  }
                  let can_push = 1;
                  for (let l = j; l > k; l--)
                  {
                    if (d0.circuit[ctrl_not][l] !== 0)
                    {
                      can_push = 0;
                      break;
                    }
                  }
                  if (can_push === 1)
                  {
                    d0.circuit[i][j] = d0.circuit[i][k];
                    d0.circuit[i][k] = 0;
                    d0.circuit[ctrl_not][j] = d0.circuit[ctrl_not][k];
                    d0.circuit[ctrl_not][k] = 0;
                    //console.log(j,k);
                    //console.log(d0.circuit[i][j], d0.circuit[i][k]);
                    break;
                  }
                  else
                  {
                    break;
                  }
                }
              }
            }
          }
          //console.log("-----");
        }
      }
      
      renderCircuit(0);
      updateFitness(d0); // 即時更新 fitness
      d0_gen = gen;
    }
    
    function setCnotArray() {
        let I = [[1,0],
                 [0,1]]
        let X = [[0,1],
                 [1,0]];
        let P0 = [[1,0],
                  [0,0]];
        let P1 = [[0,0],
                  [0,1]];
        let I_array = I;
        for (let n = 1; n < N; n++) {
            I_array = math.kron(I_array, I);
        }
        gates_arrays["I"] = I_array;

        for (let ctrl_ = 0; ctrl_ < N; ctrl_++) {
            for (let not_ = 0; not_ < N; not_++) {
                if (ctrl_ !== not_) {
                    let term0 = [[math.complex(1, 0)]]; // P0 控制項
                    let term1 = [[math.complex(1, 0)]]; // P1 控制項與 X 目標項

                    for (let k = 0; k < N; k++) {
                        if (k === ctrl_) {
                            term0 = math.kron(term0, P0);
                            term1 = math.kron(term1, P1);
                        } else if (k === not_) {
                            term0 = math.kron(term0, I);
                            term1 = math.kron(term1, X);
                        } else {
                            term0 = math.kron(term0, I);
                            term1 = math.kron(term1, I);
                        }
                    }

                    // cnot_array = term0 + term1
                    let cnot_array = [];
                    for (let i = 0; i < term0.length; i++) {
                        cnot_array[i] = [];
                        for (let j = 0; j < term0[i].length; j++) {
                            cnot_array[i][j] = math.add(term0[i][j], term1[i][j]);
                        }
                    }

                    let array_name = `CNOT(${ctrl_},${not_})`;
                    gates_arrays[array_name] = cnot_array;
                }
            }
        }
    }
    
    function setGatesArray() {
        setCnotArray();
        // 單閘 (非 ─, ⊕, ●) 的 tensor product gate array
        const gates_Matrix = [
            [[1, 0], [0, 1]],
            [[1/Math.sqrt(2), 1/Math.sqrt(2)],
             [1/Math.sqrt(2), -1/Math.sqrt(2)]],
            [[1, 0],
             [0, math.exp(math.complex(0, Math.PI / 4))]],
            [[1, 0],
             [0, math.exp(math.complex(0, -Math.PI / 4))]],
            [[1, 0], [0, 1]],
            [[1, 0], [0, 1]],
        ];

        for (let i = 0; i < gates.length; i++) {
            if (i !== 0 && i !== 4 && i !== 5) { // != "─" && != "⊕" && != "●"
                for (let j = 0; j < N; j++) {
                    let circuit_array;
                    for (let k = 0; k < N; k++) {
                        if (k === 0) {
                            circuit_array = (k === j) ? gates_Matrix[i] : gates_Matrix[0];
                        } else {
                            circuit_array = math.kron(circuit_array, (k === j) ? gates_Matrix[i] : gates_Matrix[0]);
                        }
                    }
                    let array_name = `${gates[i]}(${j})`;
                    gates_arrays[array_name] = circuit_array;

                }
            }
        }    

        // 所有可能的 depth 組合
        let set_c = [];
        for (let i = 0; i <= N; i++) {
            set_c.push([0]);
        }
        set_c[0][0] = -1;
 
        let total_depth = Math.pow(6, N);
        for (let i = 0; i < total_depth; i++) {
            set_c[0][0] += 1;

            let depth_gates = [];
            let ctrl_ = -1;
            let not_ = -1;
            let oneCNOT = true;

            for (let n = 0; n < N; n++) {
                if (set_c[n][0] > 5) {
                    set_c[n][0] = 0;
                    set_c[n + 1][0] += 1;
                }

                if (set_c[n][0] !== 4 && set_c[n][0] !== 5 && set_c[n][0] !== 0) {
                    let gate_name = `${gates[set_c[n][0]]}(${n})`;
                    depth_gates.push(gate_name);
                } else if (set_c[n][0] === 4) {
                    if (not_ === -1) {
                        not_ = n;
                    } else {
                        oneCNOT = false;
                    }
                } else if (set_c[n][0] === 5) {
                    if (ctrl_ === -1) {
                        ctrl_ = n;
                    } else {
                        oneCNOT = false;
                    }   
                }
            }

            if (((ctrl_ !== -1 && not_ !== -1) || (ctrl_ === -1 && not_ === -1)) && oneCNOT === true && depth_gates.length !== 0) {
                if (ctrl_ !== -1 && not_ !== -1) {
                    let cnot_name = `CNOT(${ctrl_},${not_})`;
                    depth_gates.push(cnot_name);
                }

                let depth_name = "";
                let depth_array = gates_arrays["I"];
                for (let x = 0; x < depth_gates.length; x++) {
                    depth_name += depth_gates[x];
                    depth_array = math.multiply(gates_arrays[depth_gates[x]], depth_array);
                }

                gates_arrays[depth_name] = depth_array;
            }
        }
    }

    function checkerDeferred(circuit) {
      let result = identityDeferred(N);

      for (let d = 0; d < circuit[0].length; d++) {
        // collect gate type per bit
        const gatesAtDepth = circuit.map(row => row[d]);
        let layerMatrix = identityDeferred(N);

        // handle single qubit gates
        for (let q = 0; q < N; q++) {
          const gid = gatesAtDepth[q];
          if (gid === 0 || gid >= 4) continue;  // ─, ⊕, ● skip
          const gate = getDeferredGate(gid);
          const applied = apply_single_qubit_gate_js(q, gate, N);
          layerMatrix = matmulDeferred(applied, layerMatrix);
        }

        // handle CNOTs
        for (let ctrl = 0; ctrl < N; ctrl++) {
          if (gatesAtDepth[ctrl] === 5) {
            for (let tgt = 0; tgt < N; tgt++) {
              if (gatesAtDepth[tgt] === 4) {
                const cnot = apply_cnot_js(ctrl, tgt, N);
                layerMatrix = matmulDeferred(cnot, layerMatrix);
              }
            }
          }
        }

        result = matmulDeferred(layerMatrix, result);
      }

      return result;
    }

    setGatesArray();

    var screenshot_ = false;
    let draggedGate = null;
    let data = [{
      gen: 1,
      circuit: [[5, 1, 5, 2, 5, 1, 5],
                [4, 2, 4, 3, 4, 0, 4]],
      fitness: 0
    }];
    let data0 = [{
      gen: 1,
      circuit: [[5, 1, 5, 2, 5, 1, 5],
                [4, 2, 4, 3, 4, 0, 4]],
      fitness: 0
    }];
    document.getElementById('genSlider').max = data.length;

    const gateMap = ['empty', 'H', 'T', 'T†', 'X', 'C'];

    const ctx = canvas.getContext('2d');
    let fitnessChart;
    // 存入當前fitnessChart顯示的電路
    let circuitData = null;

    updateFitnessChart();
    renderCircuit(1);

    // 更新矩陣顯示
    function updateMatrixDisplay(m) {
      const table = document.getElementById('matrix');
      table.innerHTML = '';
      //console.log(m);
      const size = m.size()[0];
      for (let i = 0; i < size; i++) {
        const row = document.createElement('tr');
        for (let j = 0; j < size; j++) {
          const cell = document.createElement('td');
          const v = m.get([i, j]);
          const re = math.round(math.re(v), 7);
          const im = math.round(math.im(v), 7);
          const reColor = (re === 0) ? '#ccc' : '#000';
          const imColor = (im === 0) ? '#ccc' : '#000';

          cell.innerHTML = `
            <div style="font-size:20px; line-height:1.2; text-align:center;">
              <div style="color:${reColor}">${re.toFixed(7)}</div>
              <div style="color:${imColor}">${im >= 0 ? '+' : ''}${im.toFixed(7)}i</div>
            </div>
          `;

          row.appendChild(cell);
        }
        table.appendChild(row);
      }
    }
  
    function circuitsAreEqual(a, b) {
      return JSON.stringify(a.circuit) === JSON.stringify(b.circuit);
    }

    function findPreviousChange(currentIndex) {
      for (let i = currentIndex - 1; i >= 0; i--) {
        if (!circuitsAreEqual(data[i], data[currentIndex])) return i;
      }
      return currentIndex;
    }
   
    function findNextChange(currentIndex) {
      for (let i = currentIndex + 1; i < data.length; i++) {
        if (!circuitsAreEqual(data[i], data[currentIndex])) return i;
      }
      return currentIndex;
    }

    // 監聽下拉選單改變事件
    document.getElementById("FunctionName").addEventListener("change", function() {
    const depthInput = document.getElementById("circuitDepth");

    // ✔️ 重設 generation bar 和 label
    const slider = document.getElementById('genSlider');
    const label = document.getElementById('genLabel');
    slider.value = 1;
    label.innerText = 1;

    if (this.value === "ctrlS")
    {
      d0_gen = 0;
      N = 2;
      M = 4;
      depthInput.value = M;

      TargetArrat = [
          [1, 0, 0, 0],
          [0, 1, 0, 0],
          [0, 0, 1, 0],
          [0, 0, 0, math.complex(0, 1)],
      ];
      data = [{
      gen: 1,
      circuit: [[5, 2, 5, 0],
              [4, 3, 4, 2]],
      fitness: 0
      }];
    }
    else if (this.value === "sqrt(SWAP)")
    {
      d0_gen = 0;
      N = 2;
      M = 7;
      depthInput.value = M;

      TargetArrat = [
          [1, 0,                       0,                       0],
          [0, math.complex(0.5, 0.5),  math.complex(0.5, -0.5), 0],
          [0, math.complex(0.5, -0.5), math.complex(0.5, 0.5),  0],
          [0, 0,                       0,                       1],
      ];
      data = [{
        gen: 1,
        circuit: [[5, 1, 5, 2, 5, 1, 5],
                  [4, 2, 4, 3, 4, 0, 4]],
        fitness: 0
      }];

      }
      else if (this.value === "HHL")
      {
      d0_gen = 0;
      N = 3;
      M = 12;
      depthInput.value = M;

      TargetArrat = [
          [ 0, 0,  0, math.complex(0, -1), 0, 0,  0, 0],
          [ 0, 0, -1, 0,                   0, 0,  0, 0],
          [ 0, 1,  0, 0,                   0, 0,  0, 0],
          [-1, 0,  0, 0,                   0, 0,  0, 0],
          [ 0, 0,  0, 0,                   1, 0,  0, 0],
          [ 0, 0,  0, 0,                   0, 1,  0, 0],
          [ 0, 0,  0, 0,                   0, 0, -1, 0],
          [ 0, 0,  0, 0,                   0, 0,  0, math.complex(0, 1)]
      ];
      data = [{
        gen: 1,
        circuit: [[0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],
                  [3, 5, 1, 5, 3, 3, 4, 0, 0, 4, 2, 2],
                  [3, 4, 2, 4, 3, 3, 5, 1, 4, 5, 2, 2]],
        fitness: 0
      }];
      }
      else if (this.value === "HHL_global_phase")
      {
        d0_gen = 0;
        N = 3;
        M = 11;
        depthInput.value = M;

        TargetArrat = [
            [0,  0, 0, math.complex(0, 1), 0,  0, 0, 0],
            [0,  0, 1, 0,                  0,  0, 0, 0],
            [0, -1, 0, 0,                  0,  0, 0, 0],
            [1,  0, 0, 0,                  0,  0, 0, 0],
            [0,  0, 0, 0,                 -1,  0, 0, 0],
            [0,  0, 0, 0,                  0, -1, 0, 0],
            [0,  0, 0, 0,                  0,  0, 1, 0],
            [0,  0, 0, 0,                  0,  0, 0, math.complex(0, -1)]
        ];
        data = [{
          gen: 1,
          circuit: [[0, 0, 5, 2, 2, 2, 2, 0, 0, 0, 0],
                    [2, 5, 4, 1, 2, 2, 2, 2, 4, 1, 5],
                    [2, 4, 3, 0, 0, 0, 0, 0, 5, 0, 4]],
          fitness: 0
        }];
      }
      else if (this.value === "Toffoli")
      {
        d0_gen = 0;
        N = 3;
        M = 9;
        depthInput.value = M;

        TargetArrat = [
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 1, 0]
        ];
        data = [{
          gen: 1,
          circuit: [[3, 0, 4, 2, 4, 3, 4, 2, 4],
                    [0, 4, 2, 4, 5, 3, 0, 0, 5],
                    [1, 5, 5, 5, 0, 0, 5, 3, 1]],
          fitness: 0
        }];
      }
      else if (this.value === "Peres")
      {
        d0_gen = 0;
        N = 3;
        M = 8;
        depthInput.value = M;

        TargetArrat = [
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0]
        ];
        data = [{
          gen: 1,
          circuit: [[2, 0, 0, 5, 5, 5, 0, 0],
                    [2, 4, 3, 0, 4, 2, 4, 3],
                    [1, 5, 2, 4, 3, 4, 5, 1]],
          fitness: 0
        }];
      }
      else if (this.value === "TOFPN")
      {
        d0_gen = 0;
        N = 3;
        M = 9;
        depthInput.value = M;

        TargetArrat = [
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 1]
        ];
        data = [{
          gen: 1,
          circuit: [[2, 0, 0, 5, 4, 3, 0, 4, 5],
                    [3, 4, 2, 4, 0, 3, 4, 2, 4],
                    [1, 5, 2, 0, 5, 0, 5, 5, 1]],
          fitness: 0
        }];
      }
      else if (this.value === "OR")
      {
        d0_gen = 0;
        N = 3;
        M = 9;
        depthInput.value = M;

        TargetArrat = [
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 1, 0]
        ];
        data = [{
          gen: 1,
          circuit: [[0, 4, 3, 4, 3, 4, 2, 4, 2],
                    [0, 0, 3, 5, 4, 2, 4, 5, 5],
                    [1, 5, 2, 0, 5, 5, 5, 1, 4]],
          fitness: 0
        }];
      }
      else if (this.value === "Fredkin")
      {
        d0_gen = 0;
        N = 3;
        M = 11;
        depthInput.value = M;
        TargetArrat = [
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1]
        ];
        data = [{
          gen: 1,
          circuit: [[0, 2, 4, 3, 4, 2, 4, 3, 0, 4, 0],
                    [4, 2, 0, 0, 5, 4, 0, 3, 4, 5, 4],
                    [5, 1, 5, 2, 0, 5, 5, 0, 5, 1, 5]],
          fitness: 0
        }];
      }
      else if (this.value === "Permutation")
      {
        d0_gen = 0;
        N = 3;
        M = 11;
        depthInput.value = M;

        TargetArrat = [
            [0, 0, 0, 0, 0, 0, 1, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1]
        ];
        data = [{
          gen: 1,
          circuit: [[4, 3, 4, 2, 4, 4, 2, 4, 3, 4, 4],
                    [5, 1, 5, 5, 5, 0, 5, 5, 2, 1, 5],
                    [0, 3, 0, 4, 2, 5, 4, 0, 0, 5, 0]],
          fitness: 0
        }];
      }

      gates_arrays = {};
      setGatesArray();
      const canvas = document.getElementById("circuitCanvas");
      canvas.width = leftPadding + M * gateWidth + rightPadding;
      canvas.height = topPadding + (N - 1) * qubitSpacing + bottomPadding;
      renderCircuit(1);
    });

    document.addEventListener('keydown', function (event) {
      const slider = document.getElementById('genSlider');
      let current = parseInt(slider.value);
      const max = parseInt(slider.max);
      const min = parseInt(slider.min);

      if (event.key === 'a' && current > min) {
        slider.value = current - 1;
        slider.dispatchEvent(new Event('input'));
        d0_gen = 0;
      } else if (event.key === 'd' && current < max) {
        slider.value = current + 1;
        slider.dispatchEvent(new Event('input'));
        d0_gen = 0;
      } else if (event.key === 'w') {
        const target = findPreviousChange(current - 1) + 1;
        slider.value = target;
        slider.dispatchEvent(new Event('input'));
        d0_gen = 0;
      } else if (event.key === 's') {
        const target = findNextChange(current - 1) + 1;
        slider.value = target;
        slider.dispatchEvent(new Event('input'));
        d0_gen = 0;
      }
    });

    document.getElementById('fileInput').addEventListener('change', function(evt) {
      const file = evt.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        const lines = e.target.result.split('\n').filter(l => l.trim() !== '');
        data = [];

        for (let i = 0; i < lines.length; i += 2) {
          const genNumber = parseInt(lines[i]);
          const match = lines[i + 1].matchAll(/\[([^\]]+)\]/g);
          const circuit = [];
          for (const m of match) {
            circuit.push(m[1].trim().split(/\s+/).map(Number));
          }

          // 從最後一個中括號後的部分抓取 fitness 值
          const fitnessStr = lines[i + 1].replace(/\[[^\]]+\]/g, '').trim();
          const fitness = parseFloat(fitnessStr);

          data.push({ gen: genNumber, circuit, fitness });
        }

        document.getElementById('genSlider').max = data.length;
        updateFitnessChart();
        renderCircuit(1);
        document.getElementById("fitnessChart").style.display = "block";
      };
      reader.readAsText(file);
    });

    document.getElementById('genSlider').addEventListener('input', function() {
      const gen = parseInt(this.value);
      document.getElementById('genLabel').innerText = gen;
      renderCircuit(gen);
      d0_gen = 0;
    });

    // Allow dragging
    document.querySelectorAll('.draggable-gate').forEach(gate => {
      gate.addEventListener('dragstart', (e) => {
        draggedGate = e.target.dataset.gate;
      });
    });
    
    document.querySelectorAll('.feature-button').forEach(btn => {
      btn.addEventListener('click', function () {
        // 移除其他按鈕的 active
        document.querySelectorAll('.feature-button').forEach(b => b.classList.remove('active'));
        // 設定目前按鈕為 active
        this.classList.add('active');

        // 切換對應區塊
        const tab = this.dataset.tab;
        document.getElementById("input_file").style.display = (tab === "analyzer") ? "block" : "none";
        document.getElementById("fitnessChartContainer").style.display = (tab === "analyzer") ? "block" : "none";
        document.getElementById("input_circuit_n").style.display = (tab === "editor") ? "block" : "none";
        document.getElementById("modify_mode").style.display = (tab === "editor") ? "block" : "none";
        document.getElementById("matrix_show").style.display = (tab !== "analyzer") ? "block" : "none";
        document.getElementById("HS_fitness").style.display = (tab !== "function") ? "block" : "none";
      });
    });
    
    // Setup for future drop logic
    canvas.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    var d0_gen = 0;

    // 可以雙擊移除gate的程式碼
    canvas.addEventListener('dblclick', (e) => {
      e.preventDefault();
      //console.log("你在電路區雙擊了！");
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }

      if (!d) return;
      
      const x = e.offsetX;
      const y = e.offsetY;

      const col = Math.round((x - leftPadding) / gateWidth);
      if (col < 0 || col >= d0.circuit[0].length) return;
      
      const row = Math.round((y - bottomPadding) / qubitSpacing);
      if (row < 0 || row >= d0.circuit.length) return;

      //console.log(`雙擊位置：c[${row}][${col}]`);
      if (d0.circuit[row][col] === 4 || d0.circuit[row][col] === 5)
      {
        for (let i = 0; i < d0.circuit.length; i++) 
        {
            if ((d0.circuit[i][col] === 4 || d0.circuit[i][col] === 5) && (i !== row))
            {
              d0.circuit[i][col] = 0;
            }
        }
      }
      d0.circuit[row][col] = 0;

      renderCircuit(0);
      updateFitness(d0); // 即時更新 fitness
    });

    // 可以拖拉的程式碼
    canvas.addEventListener('drop', (e) => {
      e.preventDefault();
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }

      if (!d) return;

      const x = e.offsetX;
      const y = e.offsetY;

      const col = Math.round((x - leftPadding) / gateWidth);
      if (col < 0 || col >= d0.circuit[0].length) return;
      
      const row = Math.round((y - topPadding) / qubitSpacing);
      if (row < 0 || row >= d0.circuit.length) return;

      const g = parseInt(draggedGate);

      if (d0.circuit[row][col] === 4 || d0.circuit[row][col] === 5 || g === 4 || g === 5)
      { 
        let ctrl_ = -1;
        let not_ = -1;
        for (let i = 0; i < d0.circuit.length; i++)
        {
          if (d0.circuit[i][col] === 5)
          {
            ctrl_ = i;
          }
          else if (d0.circuit[i][col] === 4)
          {
            not_ = i;
          }
        }
        if (ctrl_ !== -1 && not_ !== -1)
        {
          d0.circuit[ctrl_][col] = 0;
          d0.circuit[not_][col] = 0;
        }
      }
      d0.circuit[row][col] = g;

      let had_ctrl_not = 0;
      if (g === 4 || g === 5)
      {
        for (let i = 0; i < d0.circuit.length; i++)
        {
          if ((d0.circuit[i][col] === 4 || d0.circuit[i][col] === 5) && i !== row)
          {
            had_ctrl_not = 1;
          }
        }
        //console.log(had_ctrl_not);
      }

      if (g === 4 && had_ctrl_not === 0)
      {
        //console.log("not");
        if (row !== (d0.circuit.length - 1))
        {
          if (d0.circuit[row + 1][col] === 0)
          {
            d0.circuit[row + 1][col] = 5;
          }
        }
        else
        {
          if (d0.circuit[row - 1][col] === 0)
          {
            d0.circuit[row - 1][col] = 5;
          }
        }
      }
      else if (g === 5 && had_ctrl_not === 0)
      {
        //console.log("ctrl");
        if (row !== (d0.circuit.length - 1))
        {
          if (d0.circuit[row + 1][col] === 0)
          {
            d0.circuit[row + 1][col] = 4;
          }
        }
        else
        {
          if (d0.circuit[row - 1][col] === 0)
          {
            d0.circuit[row - 1][col] = 4;
          }
        }
      }
      //console.log(d0.circuit);

      renderCircuit(0);
      updateFitness(d0); // 即時更新 fitness
    });

    let isScrolling = false;
    canvas.addEventListener('wheel', (e) => {
      event.preventDefault();
      if (isScrolling) return;
                isScrolling = true;
                
      e.preventDefault();
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }

      if (!d) return;

      const x = e.offsetX;
      const y = e.offsetY;

      const col = Math.round((x - leftPadding) / gateWidth);
      if (col < 0 || col >= d0.circuit[0].length) return;
      
      const row = Math.round((y - topPadding) / qubitSpacing);
      if (row < 0 || row >= d0.circuit.length) return;
      
      //console.log(e);

      const wheel_ = e.deltaY;
      if (wheel_ < 0)
      {
        d0.circuit[row][col] += 1;
        if (d0.circuit[row][col] > 5)
        {
          d0.circuit[row][col] = 0;
        }
      }
      else if (wheel_ > 0)
      {
        d0.circuit[row][col] -= 1;
        if (d0.circuit[row][col] < 0)
        {
          d0.circuit[row][col] = 5;
        }
      }
      
      renderCircuit(0);
      updateFitness(d0); // 即時更新 fitness

      // 0.025秒後解除節流
      setTimeout(() => {
        isScrolling = false;
      }, 25);
    });

    // 監聽 mousedown 事件
    canvas.addEventListener("mousedown", (e) => {
      e.preventDefault();
      mouseDownPos = {
        x: e.offsetX,
        y: e.offsetY
      };
    });

    // 監聽 mouseup 事件
    canvas.addEventListener("mouseup", (e) => {
      e.preventDefault();
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }

      if (!d) return;

      mouseUpPos = {
        x: e.offsetX,
        y: e.offsetY
      };
      
      const col_start = Math.round((mouseDownPos.x - leftPadding) / gateWidth);
      if (col_start < 0 || col_start >= d0.circuit[0].length) return;
      
      const row_start = Math.round((mouseDownPos.y - topPadding) / qubitSpacing);
      if (row_start < 0 || row_start >= d0.circuit.length) return;

      const col_end = Math.round((mouseUpPos.x - leftPadding) / gateWidth);
      if (col_end < 0 || col_end >= d0.circuit[0].length) return;
      
      const row_end = Math.round((mouseUpPos.y - topPadding) / qubitSpacing);
      if (row_end < 0 || row_end >= d0.circuit.length) return;

      if (col_start !== col_end || row_start !== row_end)
      {
        if ((d0.circuit[row_start][col_start] === 4 || d0.circuit[row_start][col_start] === 5) && col_start !== col_end)
        {
          for (let i = 0; i < d0.circuit.length; i++)
          {
            if (d0.circuit[i][col_end] === 4 || d0.circuit[i][col_end] === 5)
            {
              d0.circuit[i][col_end] = 0;
            }
          }
        }
        let row_start_ = -1;
        if (d0.circuit[row_start][col_start] === 4 || d0.circuit[row_start][col_start] === 5)
        {
          for (let i = 0; i < d0.circuit.length; i++)
          {
            if ((d0.circuit[i][col_start] === 4 || d0.circuit[i][col_start] === 5) && i !== row_start)
            {
              row_start_ = i;
            }
          }
        }
        if (row_start_ !== -1 && (row_start_ + (row_end - row_start)) >= 0 && (row_start_ + (row_end - row_start)) <= (d0.circuit.length - 1)  && col_start !== col_end)
        {
          d0.circuit[row_start_ + (row_end - row_start)][col_end] = d0.circuit[row_start_][col_start];
          d0.circuit[row_start_][col_start] = 0;
          d0.circuit[row_end][col_end] = d0.circuit[row_start][col_start];
          d0.circuit[row_start][col_start] = 0;
        }
        else if (col_start === col_end && (d0.circuit[row_start][col_start] === 4 || d0.circuit[row_start][col_start] === 5) && (d0.circuit[row_end][col_end] === 4 || d0.circuit[row_end][col_end] === 5))
        {
          let flash = d0.circuit[row_start][col_start];
          d0.circuit[row_start][col_start] = d0.circuit[row_end][col_end];
          d0.circuit[row_end][col_end] = flash;
        }
        else
        {
          d0.circuit[row_end][col_end] = d0.circuit[row_start][col_start];
          d0.circuit[row_start][col_start] = 0;
        }
        renderCircuit(0);
        updateFitness(d0); // 即時更新 fitness
      }
    });

    function drawGate(x, y, label, type) {
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      if (type === 'H') {
        ctx.fillStyle = '#f88';
        ctx.fillRect(x - 15, y - 15, 30, 30);
        ctx.strokeRect(x - 15, y - 15, 30, 30);
      } else if (type === 'T' || type === 'T†') {
        ctx.fillStyle = (type === 'T') ? '#88f' : '#4cf';
        ctx.fillRect(x - 15, y - 15, 30, 30);
        ctx.strokeRect(x - 15, y - 15, 30, 30);
      } else if (type === 'X') {
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y - 8);
        ctx.lineTo(x, y + 8);
        ctx.moveTo(x - 8, y);
        ctx.lineTo(x + 8, y);
        ctx.stroke();
      } else if (type === 'C') {
        ctx.fillStyle = '#00f';
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
      } else if (type === 'X_') {
        ctx.globalAlpha = 0.5;   // 設定透明度 0.5
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y - 8);
        ctx.lineTo(x, y + 8);
        ctx.moveTo(x - 8, y);
        ctx.lineTo(x + 8, y);
        ctx.stroke();
        ctx.globalAlpha = 1.0; // ⭐ 還原透明度
      } else if (type === 'C_') {
        ctx.globalAlpha = 0.5;   // 設定透明度 0.5
        ctx.fillStyle = '#00f';
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        ctx.globalAlpha = 1.0; // ⭐ 還原透明度
      }

      if (['H', 'T', 'T†'].includes(type)) {
        ctx.fillStyle = '#000';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x, y);
      }
    }

    function updateFitness(d) {
      // ⬇️ 使用 deferred gate 符號運算版本
      const deferredMat = checkerDeferred(d.circuit); // 回傳 DeferredMatrix

      // ⬇️ 將 DeferredMatrix 轉換為數值矩陣（complex[][]）
      const size = deferredMat.length;
      const mat = math.matrix(
        deferredMat.map(row => row.map(cell => cell.evaluate()))
      );
      
      // ✅ 顯示矩陣
      updateMatrixDisplay(mat);
      if(screenshot_ === true)
      {
        captureAndCrop();
      }

      const prod = math.multiply(math.conj(math.transpose(mat)), TargetArrat);
      const num = math.abs(math.trace(prod));
      const dem = prod.size()[0];
      const fitness = 1 - num / dem;
      document.getElementById('fitnessValueShort').innerText = fitness.toFixed(53);
      document.getElementById('fitnessValueShort').setAttribute('title', `Full value: ${fitness.toFixed(53)}`);
    }

    function updateArray(d) {
      // ✅ 使用符號矩陣方式計算整個電路
      const deferredMat = checkerDeferred(d.circuit); // 回傳 DeferredMatrix

      // ✅ 將 DeferredMatrix 轉為 math.js 的複數矩陣格式（evaluate）
      const mat = math.matrix(
        deferredMat.map(row => row.map(cell => cell.evaluate()))
      );

      updateMatrixDisplay(mat);  // 顯示矩陣
      if (screenshot_ === true) {
        captureAndCrop();
      }
    }

    function renderCircuit(gen) {
      let d;
      if (gen === 0)
      {
        d = data0.find(item => item.gen === 1);
      }
      else
      {
        d = data.find(item => item.gen === gen);
      }

      if (!d) return;

      // 把目前電路存入 circuitData
      circuitData = d.circuit;

      const maxDepth = Math.max(...d.circuit.map(row => row.length));
      canvas.width = leftPadding + maxDepth * gateWidth;

      //document.getElementById('fitnessValue').innerText = d.fitness.toFixed(53);
      document.getElementById('fitnessValueShort').innerText = d.fitness.toFixed(53);
      document.getElementById('fitnessValueShort').setAttribute('title', `Full value: ${d.fitness.toFixed(53)}`);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let qY = [];

      ctx.strokeStyle = '#bbb';
      ctx.lineWidth = 2;
      ctx.beginPath();

      for (let i = 0; i < d.circuit.length; i++)
      {
        qY.push(topPadding + i * qubitSpacing);
        ctx.moveTo(0, qY[i]);
        ctx.lineTo(canvas.width, qY[i]);
      };

      ctx.stroke();

      // 畫 gate
      for (let i = 0; i < maxDepth; i++) {
        const x = leftPadding + i * gateWidth;
        let ctrl_ = -1;
        let not_ = -1;

        for (let j = 0; j < d.circuit.length; j++) {
          const gate = d.circuit[j][i];
          if (gate === undefined) continue;

          const gateName = gateMap[gate];
          if (gateName === "C") {
            ctrl_ = j;
            drawGate(x, qY[ctrl_], '', 'C_');
          } else if (gateName === "X") {
            not_ = j;
            drawGate(x, qY[not_], '', 'X_');
          } else if (gateName !== 'empty') {
            drawGate(x, qY[j], gateName, gateName);
          }
        }

        // 畫CNOT連線
        if(ctrl_ !== -1 && not_ !== -1)
        {
          drawGate(x, qY[not_], '', 'X');
          drawGate(x, qY[ctrl_], '', 'C');
          ctx.beginPath();
          ctx.moveTo(x, qY[not_]);
          ctx.lineTo(x, qY[ctrl_]);
          ctx.stroke();
        }
      }

      // 更新 Input 顯示區
      const gen_ = parseInt(document.getElementById('genSlider').value);
      const d_ = data.find(item => item.gen === gen_);
      updateArray(d_);
      
      let str_A = "";
      let str_B = "[";

      for (let i = 0; i < d.circuit.length; i++) {
        for (let j = 0; j < d.circuit[i].length; j++) {
          str_A += d.circuit[i][j];
          str_B += d.circuit[i][j];
          if (j !== d.circuit[i].length - 1) {
            str_A += " ";
            str_B += " ";
          }
        }
        str_B += "]";
        if (i !== d.circuit.length - 1) {
          str_A += "\n";
          str_B += " [";
        }
      }
    }

    function updateFitnessChart() {
      const genValues = data.map(d => d.gen);
      const fitnessValues = data.map(d => d.fitness);
      const maxGen = Math.max(...genValues);

      const trace = {
        x: genValues,
        y: fitnessValues,
        mode: 'lines+markers',
        type: 'scattergl',
        line: { color: 'rgb(0,123,255)', width: 2 },
        marker: { size: 4, color: 'rgb(0,123,255)' },
        name: 'Fitness',
        hovertemplate: 'Generation %{x:.0f}<br>Fitness %{y:.53f}<extra></extra>'
      };

      const layout = {
        title: 'Fitness over Generations',
        xaxis: {
          title: 'Generation',
          tickfont: { size: 10 },
          titlefont: { size: 12 },
          range: [0, maxGen],            // 初始顯示範圍
          rangemode: 'nonnegative',       // 禁止負軸
          tickformat: 'd',       // <-- 這行禁用 k/M 縮寫
        },
        yaxis: {
          title: 'Fitness',
          tickfont: { size: 10 },
          titlefont: { size: 12 },
          range: [0, 1],          // <-- 固定 y 軸為 0 ~ 1
        },
        margin: { l: 50, r: 30, t: 40, b: 50 },
        height: 300, // 可自行調整
        dragmode: 'zoom' // 滑鼠框選縮放，右上角按鈕支援 pan/zoom
      };

      Plotly.newPlot('fitnessChart', [trace], layout, { responsive: true });
    }

    function jumpToGeneration() {
      const input = document.getElementById('genInput');
      const slider = document.getElementById('genSlider');
      const max = parseInt(slider.max);
      const min = parseInt(slider.min);
      const value = parseInt(input.value);
      d0_gen = 0;

      if (!isNaN(value) && value >= min && value <= max) {
        slider.value = value;
        slider.dispatchEvent(new Event('input'));
      } else {
        alert(`Please enter a number between ${min} and ${max}`);
      }
    }
  
    function identityDeferred(n) {
      const size = 1 << n;
      const I = Array(size).fill(0).map(() =>
        Array(size).fill().map(() => new DeferredCpx())
      );
      for (let i = 0; i < size; i++) {
        I[i][i] = new DeferredCpx(math.complex(1, 0), false);
      }
      return I;
    }

    function kronDeferred(A, B) {
      const r1 = A.length, c1 = A[0].length;
      const r2 = B.length, c2 = B[0].length;
      const result = Array(r1 * r2).fill(0).map(() =>
        Array(c1 * c2).fill().map(() => new DeferredCpx())
      );
      for (let i = 0; i < r1; i++)
        for (let j = 0; j < c1; j++)
          for (let k = 0; k < r2; k++)
            for (let l = 0; l < c2; l++)
              result[i * r2 + k][j * c2 + l] = A[i][j].multiply(B[k][l]);
      return result;
    }

    function matmulDeferred(A, B) {
      const n = A.length, m = B[0].length, p = A[0].length;
      const result = Array(n).fill(0).map(() =>
        Array(m).fill().map(() => new DeferredCpx())
      );
      for (let i = 0; i < n; i++)
        for (let k = 0; k < p; k++)
          for (let j = 0; j < m; j++)
            result[i][j] = result[i][j].add(A[i][k].multiply(B[k][j]));
      return result;
    }
  
    function getDeferredGate(id) {
      const I = [
        [new DeferredCpx(math.complex(1, 0)), new DeferredCpx()],
        [new DeferredCpx(), new DeferredCpx(math.complex(1, 0))]
      ];
      if (id === 0) return I;

      if (id === 1) return [
        [new DeferredCpx(math.complex(1, 0), true), new DeferredCpx(math.complex(1, 0), true)],
        [new DeferredCpx(math.complex(1, 0), true), new DeferredCpx(math.complex(-1, 0), true)]
      ];

      if (id === 2) return [
        [new DeferredCpx(math.complex(1, 0)), new DeferredCpx()],
        [new DeferredCpx(), new DeferredCpx(math.complex(1, 1), true)]
      ];

      if (id === 3) return [
        [new DeferredCpx(math.complex(1, 0)), new DeferredCpx()],
        [new DeferredCpx(), new DeferredCpx(math.complex(1, -1), true)]
      ];

      throw new Error("Unknown gate id: " + id);
    }
  
    function apply_single_qubit_gate_js(target, gate, total_bits) {
      let result = (target === 0) ? gate : getDeferredGate(0); // I
      for (let i = 1; i < total_bits; i++) {
        const g = (i === target) ? gate : getDeferredGate(0);
        result = kronDeferred(result, g);
      }
      return result;
    }
  
    function apply_cnot_js(control, target, total_bits) {
      const dim = 1 << total_bits;
      const mat = Array(dim).fill().map(() =>
        Array(dim).fill().map(() => new DeferredCpx())
      );

      for (let i = 0; i < dim; i++) {
        const b_ctrl = (i >> (total_bits - 1 - control)) & 1;
        const flip = (b_ctrl) ? (i ^ (1 << (total_bits - 1 - target))) : i;
        mat[flip][i] = new DeferredCpx(math.complex(1, 0));
      }

      return mat;
    }
  
    function applyManualCircuit() {
      const input = document.getElementById("manualCircuitInput").value.trim();
      if (!input) return alert("請輸入電路內容");

      const gen = parseInt(document.getElementById("genSlider").value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      d0_gen = gen;
      if (!d) return alert("無對應 generation");

      let newCircuit = [];

      // ✅ 格式 B: 偵測是否為 [ ... ] [ ... ] 格式
      if (input.includes("[") && input.includes("]")) {
        const matches = [...input.matchAll(/\[([^\]]+)\]/g)];
        if (matches.length !== d.circuit.length) {
          return alert(`括號數量 (${matches.length}) 不符合 qubit 數 (${d.circuit.length})`);
        }

        for (let i = 0; i < matches.length; i++) {
          const rowStr = matches[i][1];
          const row = rowStr.trim().split(/\s+/).map(Number);
          newCircuit.push(row);
        }
      }
      // ✅ 格式 A: 每行一個 qubit
      else {
        const lines = input.split('\n').map(line => line.trim()).filter(line => line !== "");
        for (let i = 0; i < lines.length; i++) {
          const row = lines[i].split(/\s+/).map(Number);
          newCircuit.push(row);
        }
      }

      // ✅ 根據 newCircuit 調整 d0 circuit 深度與 qubit 數
      const newQubitCount = newCircuit.length;
      const newDepth = Math.max(...newCircuit.map(row => row.length));

      // 調整 d0 circuit 結構為 newQubitCount x newDepth
      d0.circuit = Array.from({ length: newQubitCount }, (_, q) => {
        const row = newCircuit[q] || [];
        while (row.length < newDepth) row.push(0); // 補齊深度
        return row;
      });

      // ✅ 套用電路並重新 render
      document.getElementById("circuitDepth").value = newDepth;
      const canvas = document.getElementById("circuitCanvas");
      canvas.width = leftPadding + newDepth * gateWidth + rightPadding;
      canvas.height = topPadding + (newQubitCount - 1) * qubitSpacing + bottomPadding;

      renderCircuit(0);
      updateFitness(d0);
    }

    function captureMatrix() {
      const target = document.getElementById('matrix');
      html2canvas(target).then(canvas => {
        const link = document.createElement('a');
        link.download = 'matrix_snapshot.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      });
    }
  
    function copy_circuit() {
      if (!circuitData) {
        alert('No circuit to copy!');
        return;
      }

      // 把二維陣列轉成每行用空格分隔，行與行之間用換行
      const text = circuitData.map(r => r.join(' ')).join('\n');

      navigator.clipboard.writeText(text).then(() => {
        
      }).catch(err => {
        console.error('Failed to copy: ', err);
        alert('Failed to copy circuit');
      });
    }

    // 初始化：顯示 Function Viewer，隱藏其他
    window.addEventListener('DOMContentLoaded', () => {
      document.querySelector('.feature-button[data-tab="function"]').classList.add('active');

      document.getElementById("input_file").style.display = "none";
      document.getElementById("fitnessChartContainer").style.display = "none";
      document.getElementById("input_circuit_n").style.display = "none";
      document.getElementById("matrix_show").style.display = "block";
      document.getElementById("modify_mode").style.display = "none";
      document.getElementById("HS_fitness").style.display = "none";
    });

  </script>


</body></html>