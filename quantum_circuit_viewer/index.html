<html lang="en"><head>
  <meta charset="UTF-8">
  <title>Quantum Circuit Viewer</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    #canvasContainer { margin-top: 20px; }
    canvas { border: 1px solid #ccc; }
    #fitnessChartContainer {width: 100%; height: auto; overflow-x: auto; }
    #fitnessChart { min-width: 1000px; max-width: 100%; height: 300px; /* 明確設定高度 */ }
    .gate-palette {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .draggable-gate {
      width: 40px;
      height: 40px;
      border: 1px solid #888;
      border-radius: 6px;
      text-align: center;
      line-height: 40px;
      font-weight: bold;
      font-family: Arial;
      font-size: 14px;
      user-select: none;
      cursor: grab;
    }
    .gate-wire { background-color: #eee; color: #000; }
    .gate-H { background-color: #f88; color: #000; }
    .gate-T { background-color: #88f; color: #000; }
    .gate-Td { background-color: #4cf; color: #000; }
    .gate-X { background-color: #fff; color: #00f; border: 2px solid #00f; border-radius: 80%; }
    .gate-C { background-color: #fff; color: #00f; border: 2px solid #00f; border-radius: 80%; }

    .matrix td {
      padding: 8px;
      border: 1px solid #000;
      text-align: center;
      vertical-align: middle;
      font-family: monospace;
      font-size: 20px;
      height: 50px;
      width: 100px;
    }
    .feature-button {
    display: inline-block;
    padding: 10px 18px;
    margin: 0 10px;
    border-radius: 10px;
    background-color: #007BFF;
    color: white;
    font-size: 15px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    transition: all 0.25s ease-in-out;
  }

  .feature-button:hover {
    background-color: #0056b3;
    transform: scale(1.05);
  }

  .feature-button-container {
    display: flex;
    justify-content: left;
    margin-top: 20px;
    gap: 20px;
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
</head>
<body>
  <h2>Quantum Circuit Viewer</h2>

  <div class="feature-button-container">
    <div id="FunctionView_mod" class="feature-button">查看不同 Function 的解</div>
    <div id="DrogCircuit" class="feature-button">使用者拖拉電路</div>
    <div id="DynFitTrack" class="feature-button">動態視覺化分析</div>
  </div>
  <!-- 下拉式選單 -->
  <div style="margin-top: 20px;">
    <label for="FunctionName">Target Function:</label>
    <select id="FunctionName">
        <option value="sqrt(SWAP)">sqrt(SWAP)</option>
        <option value="ctrlS">ctrl-S</option>
        <option value="HHL">HHL</option>
        <option value="HHL_global_phase">HHL_global phase(-1)</option>
        <option value="Toffoli">Toffoli</option>
        <option value="Peres">Peres</option>
        <option value="TOFPN">TOF-PN</option>
        <option value="OR">OR</option>
        <option value="Fredkin">Fredkin</option>
        <option value="Permutation">Permutation</option>
    </select>
  
    <label for="circuitDepth">Depth 數：</label>
    <input type="number" id="circuitDepth" value="7" min="1" max="100" style="width: 50px;">
    <button onclick="setCircuitDepth()">套用</button>
  </div>

  <div id="input_file" style="margin-top: 10px;">
    <input type="file" id="fileInput">
    <label for="genInput">Go to Generation:</label>
      <input type="number" id="genInput" min="1" style="width: 80px;">
      <button onclick="jumpToGeneration()">Go</button>

    <div style="margin-top: 10px;">
      Gen.: 
      <input type="range" id="genSlider" min="1" max="10000" value="1" style="width: 450px;">
      <span id="genLabel">1</span>
    </div>
  </div>

  <div id="input_circuit_n" style="margin-top: 10px;">
    <label for="manualCircuitInput"><strong>輸入電路：</strong></label><br>
    <span style="font-size: 14px;">
      支援以下兩種格式，按「套用電路」以直接修改目前 generation 的電路：
      <ul style="margin-top: 4px; margin-bottom: 6px; padding-left: 20px;">
        <li><strong>格式 A</strong>：每行代表一個 qubit，gate 用空格分隔</li>
        <pre id="circuit_n">
3 3 5 1 0 1 5 3 0 3 0 3
5 1 2 5 0 5 3 0 2 4 1 5
4 3 4 4 3 4 4 3 3 5 2 4</pre>

        <li><strong>格式 B</strong>：每個 qubit 放在一個 <code>[ ... ]</code> 括號中</li>
        <pre>[3 3 5 1 0 1 5 3 0 3 0 3] [5 1 2 5 0 5 3 0 2 4 1 5] [4 3 4 4 3 4 4 3 3 5 2 4]</pre>
      </ul>
    </span>
    <textarea id="manualCircuitInput" rows="4" cols="80" placeholder="請貼上格式 A 或 B 的電路 gate 編碼..."></textarea>
    <button onclick="applyManualCircuit()">套用電路</button>
  </div>

  <div style="display: inline-block; vertical-align: top; margin-top: 10px;">
    <div id="canvasContainer" style="margin-top: 10px;">
      <div  style="display: inline-block; vertical-align: top;">
        <canvas id="circuitCanvas"></canvas>
      </div>
      <button onclick="clear_circuit()">清空</button>
      <button onclick="screenshot_onoff()">截圖</button>
    </div>
  </div>

  <div style="margin-top: 10px;">
    上方電路與Target Function的 Fitness: <span id="fitnessValue">0.20943058495790511930323418710031546652317047119140625</span>
  </div>

  <div style="margin-top: 10px;">
    <!-- ✅ Gate Palette -->
    <label><strong>電路gate變更，請拖曳下方gate到上面的電路：</strong></label><br>
    <div id="put_gate" class="gate-palette" style="margin-top: 10px;">
      <div class="draggable-gate gate-wire" draggable="true" data-gate="0">W</div>
      <div class="draggable-gate gate-H" draggable="true" data-gate="1">H</div>
      <div class="draggable-gate gate-T" draggable="true" data-gate="2">T</div>
      <div class="draggable-gate gate-Td" draggable="true" data-gate="3">T†</div>
      <div class="draggable-gate gate-X" draggable="true" data-gate="4">⊕</div>
      <div class="draggable-gate gate-C" draggable="true" data-gate="5">●</div>
    </div>
  </div>

  <div id="matrix_show" style="margin-top: 10px;">
    <label><strong>電路矩陣：</strong></label><br>
    <div style="display: inline-block; vertical-align: top;">
      <table id="matrix" class="matrix"></table>
    </div>
    <button onclick="captureMatrix()">擷取矩陣</button>
  </div>

  <div id="fitnessChartContainer">
    <div id="fitnessChart" style="width: 100%; height: 100%;"></div>

    <div id="hot-key"><br><br>a:last gen, d:next gen, w:last change, s:next change, double click:remove gate</div>
  </div>

  <script>
    document.getElementById("input_file").style.display = "none";
    document.getElementById("fitnessChart").style.display = "none";
    document.getElementById("input_circuit_n").style.display = "none";
    document.getElementById("hot-key").style.display = "none";

    document.getElementById("FunctionView_mod").addEventListener("click", function() {
      document.getElementById("input_file").style.display = "none";
      document.getElementById("fitnessChart").style.display = "none";
      document.getElementById("input_circuit_n").style.display = "none";
      document.getElementById("matrix_show").style.display = "block";
      document.getElementById("hot-key").style.display = "none";
    });
    document.getElementById("DrogCircuit").addEventListener("click", function() {
      document.getElementById("input_file").style.display = "none";
      document.getElementById("fitnessChart").style.display = "none";
      document.getElementById("input_circuit_n").style.display = "block";
      document.getElementById("matrix_show").style.display = "block";
      document.getElementById("hot-key").style.display = "none";
    });
    document.getElementById("DynFitTrack").addEventListener("click", function() {
      document.getElementById("input_file").style.display = "block";
      document.getElementById("fitnessChart").style.display = "block";
      document.getElementById("input_circuit_n").style.display = "none";
      document.getElementById("matrix_show").style.display = "none";
      document.getElementById("hot-key").style.display = "block";
    });

    let M = document.getElementById("circuitDepth").value;
    let N = 2;

    M = parseInt(M);  // 確保轉成整數
    const canvas = document.getElementById("circuitCanvas");
    canvas.width = 60 + 60 * M;
    canvas.height = 50 * N + 50;

    let TargetArrat = [
        [1, 0, 0, 0],
        [0, math.complex(0.5, 0.5), math.complex(0.5, -0.5), 0],
        [0, math.complex(0.5, -0.5), math.complex(0.5, 0.5), 0],
        [0, 0, 0, 1],
    ];

    class DeferredCpx {
      constructor(val = math.complex(0, 0), hasSqrt2 = false) {
        this.real = math.complex(0, 0);
        this.real_sqrt2 = math.complex(0, 0);
        this.imag = math.complex(0, 0);
        this.imag_sqrt2 = math.complex(0, 0);

        if (hasSqrt2) {
          this.real_sqrt2 = math.complex(val.re, 0);
          this.imag_sqrt2 = math.complex(val.im, 0);
        } else {
          this.real = math.complex(val.re, 0);
          this.imag = math.complex(val.im, 0);
        }
      }

      add(other) {
        const r = new DeferredCpx();
        r.real = math.add(this.real, other.real);
        r.real_sqrt2 = math.add(this.real_sqrt2, other.real_sqrt2);
        r.imag = math.add(this.imag, other.imag);
        r.imag_sqrt2 = math.add(this.imag_sqrt2, other.imag_sqrt2);
        return r;
      }

      addInPlace(other) {
        this.real = math.add(this.real, other.real);
        this.real_sqrt2 = math.add(this.real_sqrt2, other.real_sqrt2);
        this.imag = math.add(this.imag, other.imag);
        this.imag_sqrt2 = math.add(this.imag_sqrt2, other.imag_sqrt2);
        return this;
      }

      multiply(other) {
        const r = new DeferredCpx();
        const half = 0.5;

        // real x real
        r.real = math.add(r.real, math.multiply(this.real, other.real));
        r.real_sqrt2 = math.add(r.real_sqrt2, math.multiply(this.real, other.real_sqrt2));
        r.real_sqrt2 = math.add(r.real_sqrt2, math.multiply(this.real_sqrt2, other.real));
        r.real = math.add(r.real, math.multiply(this.real_sqrt2, other.real_sqrt2).mul(half));

        // real x imag
        r.imag = math.add(r.imag, math.multiply(this.real, other.imag));
        r.imag_sqrt2 = math.add(r.imag_sqrt2, math.multiply(this.real, other.imag_sqrt2));
        r.imag_sqrt2 = math.add(r.imag_sqrt2, math.multiply(this.real_sqrt2, other.imag));
        r.imag = math.add(r.imag, math.multiply(this.real_sqrt2, other.imag_sqrt2).mul(half));

        // imag x real
        r.imag = math.add(r.imag, math.multiply(this.imag, other.real));
        r.imag_sqrt2 = math.add(r.imag_sqrt2, math.multiply(this.imag, other.real_sqrt2));
        r.imag_sqrt2 = math.add(r.imag_sqrt2, math.multiply(this.imag_sqrt2, other.real));
        r.imag = math.add(r.imag, math.multiply(this.imag_sqrt2, other.real_sqrt2).mul(half));

        // imag x imag
        r.real = math.subtract(r.real, math.multiply(this.imag, other.imag));
        r.real_sqrt2 = math.subtract(r.real_sqrt2, math.multiply(this.imag, other.imag_sqrt2));
        r.real_sqrt2 = math.subtract(r.real_sqrt2, math.multiply(this.imag_sqrt2, other.imag));
        r.real = math.subtract(r.real, math.multiply(this.imag_sqrt2, other.imag_sqrt2).mul(half));

        return r;
      }

      evaluate() {
        const sqrt2 = Math.SQRT2;
        return math.add(
          math.add(this.real, math.divide(this.real_sqrt2, sqrt2)),
          math.multiply(math.complex(0, 1),
            math.add(this.imag, math.divide(this.imag_sqrt2, sqrt2))
          )
        );
      }
    }
 
    // 監聽下拉選單改變事件
    document.getElementById("FunctionName").addEventListener("change", function() {
      const depthInput = document.getElementById("circuitDepth");

      if (this.value === "ctrlS")
      {
        d0_gen = 0;
        N = 2;
        M = 4;
        depthInput.value = M;

        TargetArrat = [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, math.complex(0, 1)],
        ];
        data = [{
          gen: 1,
          circuit: [[5, 2, 5, 0],
                    [4, 3, 4, 2]],
          fitness: 0
        }];

        gates_arrays = {};
        setGatesArray();
        const canvas = document.getElementById("circuitCanvas");
        canvas.width = 60 + 60 * M;      // 更新寬度（startX + stepX * depth）
        canvas.height = 50 * N + 50;     // 更新高度（每條線50px + 上下邊界）
        renderCircuit(1);
      }
      else if (this.value === "sqrt(SWAP)")
      {
        d0_gen = 0;
        N = 2;
        M = 7;
        depthInput.value = M;

        TargetArrat = [
            [1, 0,                       0,                       0],
            [0, math.complex(0.5, 0.5),  math.complex(0.5, -0.5), 0],
            [0, math.complex(0.5, -0.5), math.complex(0.5, 0.5),  0],
            [0, 0,                       0,                       1],
        ];
        data = [{
          gen: 1,
          circuit: [[5, 1, 5, 2, 5, 1, 5],
                    [4, 2, 4, 3, 4, 0, 4]],
          fitness: 0
        }];

        gates_arrays = {};
        setGatesArray();
        const canvas = document.getElementById("circuitCanvas");
        canvas.width = 60 + 60 * M;      // 更新寬度（startX + stepX * depth）
        canvas.height = 50 * N + 50;     // 更新高度（每條線50px + 上下邊界）
        renderCircuit(1);
      }
      else if (this.value === "HHL")
      {
        d0_gen = 0;
        N = 3;
        M = 12;
        depthInput.value = M;

        TargetArrat = [
            [ 0, 0,  0, math.complex(0, -1), 0, 0,  0, 0],
            [ 0, 0, -1, 0,                   0, 0,  0, 0],
            [ 0, 1,  0, 0,                   0, 0,  0, 0],
            [-1, 0,  0, 0,                   0, 0,  0, 0],
            [ 0, 0,  0, 0,                   1, 0,  0, 0],
            [ 0, 0,  0, 0,                   0, 1,  0, 0],
            [ 0, 0,  0, 0,                   0, 0, -1, 0],
            [ 0, 0,  0, 0,                   0, 0,  0, math.complex(0, 1)]
        ];
        data = [{
          gen: 1,
          circuit: [[0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],
                    [3, 5, 1, 5, 3, 3, 4, 0, 0, 4, 2, 2],
                    [3, 4, 2, 4, 3, 3, 5, 1, 4, 5, 2, 2]],
          fitness: 0
        }];

        gates_arrays = {};
        setGatesArray();
        const canvas = document.getElementById("circuitCanvas");
        canvas.width = 60 + 60 * M;
        canvas.height = 50 * N + 50;
        renderCircuit(1);
      }
      else if (this.value === "HHL_global_phase")
      {
        d0_gen = 0;
        N = 3;
        M = 11;
        depthInput.value = M;

        TargetArrat = [
            [0,  0, 0, math.complex(0, 1), 0,  0, 0, 0],
            [0,  0, 1, 0,                  0,  0, 0, 0],
            [0, -1, 0, 0,                  0,  0, 0, 0],
            [1,  0, 0, 0,                  0,  0, 0, 0],
            [0,  0, 0, 0,                 -1,  0, 0, 0],
            [0,  0, 0, 0,                  0, -1, 0, 0],
            [0,  0, 0, 0,                  0,  0, 1, 0],
            [0,  0, 0, 0,                  0,  0, 0, math.complex(0, -1)]
        ];
        data = [{
          gen: 1,
          circuit: [[0, 0, 5, 2, 2, 2, 2, 0, 0, 0, 0],
                    [2, 5, 4, 1, 2, 2, 2, 2, 4, 1, 5],
                    [2, 4, 3, 0, 0, 0, 0, 0, 5, 0, 4]],
          fitness: 0
        }];

        gates_arrays = {};
        setGatesArray();
        const canvas = document.getElementById("circuitCanvas");
        canvas.width = 60 + 60 * M;
        canvas.height = 50 * N + 50;
        renderCircuit(1);
      }
      else if (this.value === "Toffoli")
      {
        d0_gen = 0;
        N = 3;
        M = 9;
        depthInput.value = M;

        TargetArrat = [
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 1, 0]
        ];
        data = [{
          gen: 1,
          circuit: [[3, 0, 4, 2, 4, 3, 4, 2, 4],
                    [0, 4, 2, 4, 5, 3, 0, 0, 5],
                    [1, 5, 5, 5, 0, 0, 5, 3, 1]],
          fitness: 0
        }];

        gates_arrays = {};
        setGatesArray();
        const canvas = document.getElementById("circuitCanvas");
        canvas.width = 60 + 60 * M;
        canvas.height = 50 * N + 50;
        renderCircuit(1);
      }
      else if (this.value === "Peres")
      {
        d0_gen = 0;
        N = 3;
        M = 8;
        depthInput.value = M;

        TargetArrat = [
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0]
        ];
        data = [{
          gen: 1,
          circuit: [[2, 0, 0, 5, 5, 5, 0, 0],
                    [2, 4, 3, 0, 4, 2, 4, 3],
                    [1, 5, 2, 4, 3, 4, 5, 1]],
          fitness: 0
        }];

        gates_arrays = {};
        setGatesArray();
        const canvas = document.getElementById("circuitCanvas");
        canvas.width = 60 + 60 * M;
        canvas.height = 50 * N + 50;
        renderCircuit(1);
      }
      else if (this.value === "TOFPN")
      {
        d0_gen = 0;
        N = 3;
        M = 9;
        depthInput.value = M;

        TargetArrat = [
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 1]
        ];
        data = [{
          gen: 1,
          circuit: [[2, 0, 0, 5, 4, 3, 0, 4, 5],
                    [3, 4, 2, 4, 0, 3, 4, 2, 4],
                    [1, 5, 2, 0, 5, 0, 5, 5, 1]],
          fitness: 0
        }];

        gates_arrays = {};
        setGatesArray();
        const canvas = document.getElementById("circuitCanvas");
        canvas.width = 60 + 60 * M;
        canvas.height = 50 * N + 50;
        renderCircuit(1);
      }
      else if (this.value === "OR")
      {
        d0_gen = 0;
        N = 3;
        M = 9;
        depthInput.value = M;

        TargetArrat = [
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 1, 0]
        ];
        data = [{
          gen: 1,
          circuit: [[0, 4, 3, 4, 3, 4, 2, 4, 2],
                    [0, 0, 3, 5, 4, 2, 4, 5, 5],
                    [1, 5, 2, 0, 5, 5, 5, 1, 4]],
          fitness: 0
        }];

        gates_arrays = {};
        setGatesArray();
        const canvas = document.getElementById("circuitCanvas");
        canvas.width = 60 + 60 * M;
        canvas.height = 50 * N + 50;
        renderCircuit(1);
      }
      else if (this.value === "Fredkin")
      {
        d0_gen = 0;
        N = 3;
        M = 11;
        depthInput.value = M;

        TargetArrat = [
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1]
        ];
        data = [{
          gen: 1,
          circuit: [[0, 2, 4, 3, 4, 2, 4, 3, 0, 4, 0],
                    [4, 2, 0, 0, 5, 4, 0, 3, 4, 5, 4],
                    [5, 1, 5, 2, 0, 5, 5, 0, 5, 1, 5]],
          fitness: 0
        }];

        gates_arrays = {};
        setGatesArray();
        const canvas = document.getElementById("circuitCanvas");
        canvas.width = 60 + 60 * M;
        canvas.height = 50 * N + 50;
        renderCircuit(1);
      }
      else if (this.value === "Permutation")
      {
        d0_gen = 0;
        N = 3;
        M = 11;
        depthInput.value = M;

        TargetArrat = [
            [0, 0, 0, 0, 0, 0, 1, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0],
            [1, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1]
        ];
        data = [{
          gen: 1,
          circuit: [[4, 3, 4, 2, 4, 4, 2, 4, 3, 4, 4],
                    [5, 1, 5, 5, 5, 0, 5, 5, 2, 1, 5],
                    [0, 3, 0, 4, 2, 5, 4, 0, 0, 5, 0]],
          fitness: 0
        }];

        gates_arrays = {};
        setGatesArray();
        const canvas = document.getElementById("circuitCanvas");
        canvas.width = 60 + 60 * M;
        canvas.height = 50 * N + 50;
        renderCircuit(1);
      }

        
    });
    
    function setCircuitDepth(){
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      const m_ = document.getElementById("circuitDepth").value;
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }
      if (m_ > d0.circuit[0].length)
      {
        for (let i = d0.circuit[0].length; i < m_; i++)
        {
          for (let j = 0; j < d0.circuit.length; j++)
          {
            d0.circuit[j].push(0);
          }
        }
      }

      // ⭐ 動態更新 canvas 寬度（每個 gate 寬度 60px，加上起始邊界）
      const canvas = document.getElementById("circuitCanvas");
      const newWidth = 60 + 60 * m_;  // startX + stepX * depth
      canvas.width = newWidth;

      renderCircuit(0);
      //console.log(d.circuit);
    }

    function clear_circuit()
    {
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      //d0.circuit = JSON.parse(JSON.stringify(d.circuit));
      //d0.fitness = JSON.parse(JSON.stringify(d.fitness));
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }
      for (let i = 0; i < d.circuit.length; i++)
      {
        for (let j = 0; j < d.circuit[i].length; j++)
        {
          d0.circuit[i][j] = 0;
        }
      }
      renderCircuit(0);
      updateFitness(d0); // 即時更新 fitness
      d0_gen = gen;
    }
    
    let gates = [ "─","H","t","T","⊕","●" ];
    let gates_arrays = {};
    
    function setCnotArray() {
        let I = [[1,0],
                 [0,1]]
        let X = [[0,1],
                 [1,0]];
        let P0 = [[1,0],
                  [0,0]];
        let P1 = [[0,0],
                  [0,1]];
        let I_array = I;
        for (let n = 1; n < N; n++) {
            I_array = math.kron(I_array, I);
        }
        gates_arrays["I"] = I_array;

        for (let ctrl_ = 0; ctrl_ < N; ctrl_++) {
            for (let not_ = 0; not_ < N; not_++) {
                if (ctrl_ !== not_) {
                    let term0 = [[math.complex(1, 0)]]; // P0 控制項
                    let term1 = [[math.complex(1, 0)]]; // P1 控制項與 X 目標項

                    for (let k = 0; k < N; k++) {
                        if (k === ctrl_) {
                            term0 = math.kron(term0, P0);
                            term1 = math.kron(term1, P1);
                        } else if (k === not_) {
                            term0 = math.kron(term0, I);
                            term1 = math.kron(term1, X);
                        } else {
                            term0 = math.kron(term0, I);
                            term1 = math.kron(term1, I);
                        }
                    }

                    // cnot_array = term0 + term1
                    let cnot_array = [];
                    for (let i = 0; i < term0.length; i++) {
                        cnot_array[i] = [];
                        for (let j = 0; j < term0[i].length; j++) {
                            cnot_array[i][j] = math.add(term0[i][j], term1[i][j]);
                        }
                    }

                    let array_name = `CNOT(${ctrl_},${not_})`;
                    gates_arrays[array_name] = cnot_array;
                }
            }
        }
    }
    
    function setGatesArray() {
        setCnotArray();
        // 單閘 (非 ─, ⊕, ●) 的 tensor product gate array
        const gates_Matrix = [
            [[1, 0], [0, 1]],
            [[1/Math.sqrt(2), 1/Math.sqrt(2)],
             [1/Math.sqrt(2), -1/Math.sqrt(2)]],
            [[1, 0],
             [0, math.exp(math.complex(0, Math.PI / 4))]],
            [[1, 0],
             [0, math.exp(math.complex(0, -Math.PI / 4))]],
            [[1, 0], [0, 1]],
            [[1, 0], [0, 1]],
        ];

        for (let i = 0; i < gates.length; i++) {
            if (i !== 0 && i !== 4 && i !== 5) { // != "─" && != "⊕" && != "●"
                for (let j = 0; j < N; j++) {
                    let circuit_array;
                    for (let k = 0; k < N; k++) {
                        if (k === 0) {
                            circuit_array = (k === j) ? gates_Matrix[i] : gates_Matrix[0];
                        } else {
                            circuit_array = math.kron(circuit_array, (k === j) ? gates_Matrix[i] : gates_Matrix[0]);
                        }
                    }
                    let array_name = `${gates[i]}(${j})`;
                    gates_arrays[array_name] = circuit_array;

                }
            }
        }    

        // 所有可能的 depth 組合
        let set_c = [];
        for (let i = 0; i <= N; i++) {
            set_c.push([0]);
        }
        set_c[0][0] = -1;
 
        let total_depth = Math.pow(6, N);
        for (let i = 0; i < total_depth; i++) {
            set_c[0][0] += 1;

            let depth_gates = [];
            let ctrl_ = -1;
            let not_ = -1;
            let oneCNOT = true;

            for (let n = 0; n < N; n++) {
                if (set_c[n][0] > 5) {
                    set_c[n][0] = 0;
                    set_c[n + 1][0] += 1;
                }

                if (set_c[n][0] !== 4 && set_c[n][0] !== 5 && set_c[n][0] !== 0) {
                    let gate_name = `${gates[set_c[n][0]]}(${n})`;
                    depth_gates.push(gate_name);
                } else if (set_c[n][0] === 4) {
                    if (not_ === -1) {
                        not_ = n;
                    } else {
                        oneCNOT = false;
                    }
                } else if (set_c[n][0] === 5) {
                    if (ctrl_ === -1) {
                        ctrl_ = n;
                    } else {
                        oneCNOT = false;
                    }   
                }
            }

            if (((ctrl_ !== -1 && not_ !== -1) || (ctrl_ === -1 && not_ === -1)) && oneCNOT === true && depth_gates.length !== 0) {
                if (ctrl_ !== -1 && not_ !== -1) {
                    let cnot_name = `CNOT(${ctrl_},${not_})`;
                    depth_gates.push(cnot_name);
                }

                let depth_name = "";
                let depth_array = gates_arrays["I"];
                for (let x = 0; x < depth_gates.length; x++) {
                    depth_name += depth_gates[x];
                    depth_array = math.multiply(gates_arrays[depth_gates[x]], depth_array);
                }

                gates_arrays[depth_name] = depth_array;
            }
        }
    }

    function checkerDeferred(circuit) {
      let result = identityDeferred(N);

      for (let d = 0; d < circuit[0].length; d++) {
        // collect gate type per bit
        const gatesAtDepth = circuit.map(row => row[d]);
        let layerMatrix = identityDeferred(N);

        // handle single qubit gates
        for (let q = 0; q < N; q++) {
          const gid = gatesAtDepth[q];
          if (gid === 0 || gid >= 4) continue;  // ─, ⊕, ● skip
          const gate = getDeferredGate(gid);
          const applied = apply_single_qubit_gate_js(q, gate, N);
          layerMatrix = matmulDeferred(applied, layerMatrix);
        }

        // handle CNOTs
        for (let ctrl = 0; ctrl < N; ctrl++) {
          if (gatesAtDepth[ctrl] === 5) {
            for (let tgt = 0; tgt < N; tgt++) {
              if (gatesAtDepth[tgt] === 4) {
                const cnot = apply_cnot_js(ctrl, tgt, N);
                layerMatrix = matmulDeferred(cnot, layerMatrix);
              }
            }
          }
        }

        result = matmulDeferred(layerMatrix, result);
      }

      return result;
    }

    setGatesArray();

    var screenshot_ = false;
    let draggedGate = null;
    let data = [{
      gen: 1,
      circuit: [[5, 1, 5, 2, 5, 1, 5],
                [4, 2, 4, 3, 4, 0, 4]],
      fitness: 0
    }];
    let data0 = [{
      gen: 1,
      circuit: [[5, 1, 5, 2, 5, 1, 5],
                [4, 2, 4, 3, 4, 0, 4]],
      fitness: 0
    }];
    document.getElementById('genSlider').max = data.length;

    //let data = [{
    //  gen: 1,
    //  q0: [5, 1, 5, 2, 5, 1, 5],
    //  q1: [4, 2, 4, 3, 4, 0, 4],
    //  fitness: 0
    //}];

    const gateMap = ['empty', 'H', 'T', 'T†', 'X', 'C'];

    const ctx = canvas.getContext('2d');
    let fitnessChart;

    updateFitnessChart();
    renderCircuit(1);

    function screenshot_onoff() {
      let result_div = document.getElementById('result');
      result_div.innerHTML = "";
      if(screenshot_ === true)
      {
        screenshot_ = false;
      }
      else
      {
        screenshot_ = true;
        captureAndCrop();
      }
    }
    
    function captureAndCrop() {
      const target = document.getElementById("circuitCanvas");
      const canvasWidth = target.width;
      const canvasHeight = target.height;
      
      html2canvas(target).then(originalCanvas => {
        // 建立新 canvas 來存放裁切的內容
        const cropCanvas = document.createElement("canvas");
        const cropCtx = cropCanvas.getContext("2d");

        // 這裡設定你要裁切的區域
        const cropX = 15;   // 從左邊裁切 15px
        const cropY = 30;   // 從上方裁切 33px
        const cropWidth = canvasWidth - 30;
        const cropHeight = canvasHeight - 40;

        cropCanvas.width = cropWidth;
        cropCanvas.height = cropHeight;

        // 將原始 canvas 的部分內容畫到新 canvas 上
        cropCtx.drawImage(
          originalCanvas,
          cropX, cropY,          // 原圖要開始裁切的位置
          cropWidth, cropHeight, // 裁切的寬高
          0, 0,                   // 貼到新 canvas 的位置
          cropWidth, cropHeight  // 新 canvas 寬高
        );

        // 加到畫面上
        const result = document.getElementById("result");
        result.innerHTML = ''; // 清除舊圖
        result.appendChild(cropCanvas);
      });
    }

    // 更新矩陣顯示
    function updateMatrixDisplay(m) {
      const table = document.getElementById('matrix');
      table.innerHTML = '';
      //console.log(m);
      const size = m.size()[0];
      for (let i = 0; i < size; i++) {
        const row = document.createElement('tr');
        for (let j = 0; j < size; j++) {
          const cell = document.createElement('td');
          const v = m.get([i, j]);
          const re = math.round(math.re(v), 7);
          const im = math.round(math.im(v), 7);
          const reColor = (re === 0) ? '#ccc' : '#000';
          const imColor = (im === 0) ? '#ccc' : '#000';

          cell.innerHTML = `
            <div style="font-size:20px; line-height:1.2; text-align:center;">
              <div style="color:${reColor}">${re.toFixed(7)}</div>
              <div style="color:${imColor}">${im >= 0 ? '+' : ''}${im.toFixed(7)}i</div>
            </div>
          `;

          row.appendChild(cell);
        }
        table.appendChild(row);
      }
    }
  
    function circuitsAreEqual(a, b) {
      return JSON.stringify(a.circuit) === JSON.stringify(b.circuit);
    }

    function findPreviousChange(currentIndex) {
      for (let i = currentIndex - 1; i >= 0; i--) {
        if (!circuitsAreEqual(data[i], data[currentIndex])) return i;
      }
      return currentIndex;
    }
   
    function findNextChange(currentIndex) {
      for (let i = currentIndex + 1; i < data.length; i++) {
        if (!circuitsAreEqual(data[i], data[currentIndex])) return i;
      }
      return currentIndex;
    }

    document.addEventListener('keydown', function (event) {
      const slider = document.getElementById('genSlider');
      let current = parseInt(slider.value);
      const max = parseInt(slider.max);
      const min = parseInt(slider.min);

      if (event.key === 'a' && current > min) {
        slider.value = current - 1;
        slider.dispatchEvent(new Event('input'));
        d0_gen = 0;
      } else if (event.key === 'd' && current < max) {
        slider.value = current + 1;
        slider.dispatchEvent(new Event('input'));
        d0_gen = 0;
      } else if (event.key === 'w') {
        const target = findPreviousChange(current - 1) + 1;
        slider.value = target;
        slider.dispatchEvent(new Event('input'));
        d0_gen = 0;
      } else if (event.key === 's') {
        const target = findNextChange(current - 1) + 1;
        slider.value = target;
        slider.dispatchEvent(new Event('input'));
        d0_gen = 0;
      }
    });

    document.getElementById('fileInput').addEventListener('change', function(evt) {
      const file = evt.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        const lines = e.target.result.split('\n').filter(l => l.trim() !== '');
        data = [];

        for (let i = 0; i < lines.length; i += 2) {
          const genNumber = parseInt(lines[i]);
          const match = lines[i + 1].matchAll(/\[([^\]]+)\]/g);
          const circuit = [];
          for (const m of match) {
            circuit.push(m[1].trim().split(/\s+/).map(Number));
          }

          // 從最後一個中括號後的部分抓取 fitness 值
          const fitnessStr = lines[i + 1].replace(/\[[^\]]+\]/g, '').trim();
          const fitness = parseFloat(fitnessStr);

          data.push({ gen: genNumber, circuit, fitness });
        }

        document.getElementById('genSlider').max = data.length;
        updateFitnessChart();
        renderCircuit(1);
        document.getElementById("fitnessChart").style.display = "block";
      };
      reader.readAsText(file);
    });

    document.getElementById('genSlider').addEventListener('input', function() {
      const gen = parseInt(this.value);
      document.getElementById('genLabel').innerText = gen;
      renderCircuit(gen);
      d0_gen = 0;
    });

    //document.addEventListener('keydown', function (event) {
    //  const slider = document.getElementById('genSlider');
    //  let current = parseInt(slider.value);
    //  const max = parseInt(slider.max);
    //  const min = parseInt(slider.min);

    //  if (event.key === 'ArrowLeft') {
    //    if (current > min) {
    //      slider.value = current - 1;
    //      slider.dispatchEvent(new Event('input'));
    //      d0_gen = 0;
    //    }
    //  } else if (event.key === 'ArrowRight') {
    //    if (current < max) {
    //      slider.value = current + 1;
    //      slider.dispatchEvent(new Event('input'));
    //      d0_gen = 0;
    //    }
    //  }
    //});

    // Allow dragging
    document.querySelectorAll('.draggable-gate').forEach(gate => {
      gate.addEventListener('dragstart', (e) => {
        draggedGate = e.target.dataset.gate;
      });
    });

    // Setup for future drop logic
    canvas.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    var d0_gen = 0;

    // 可以雙擊移除gate的程式碼
    canvas.addEventListener('dblclick', (e) => {
      e.preventDefault();
      //console.log("你在電路區雙擊了！");
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }

      if (!d) return;
      
      const x = e.offsetX;
      const y = e.offsetY;

      const col = Math.round((x - 60) / 60);
      if (col < 0 || col >= d0.circuit[0].length) return;
      
      const row = Math.round((y - 50) / 50);
      if (row < 0 || row >= d0.circuit.length) return;

      //console.log(`雙擊位置：c[${row}][${col}]`);
      if (d0.circuit[row][col] === 4 || d0.circuit[row][col] === 5)
      {
        for (let i = 0; i < d0.circuit.length; i++) 
        {
            if ((d0.circuit[i][col] === 4 || d0.circuit[i][col] === 5) && (i !== row))
            {
              d0.circuit[i][col] = 0;
            }
        }
      }
      d0.circuit[row][col] = 0;

      renderCircuit(0);
      updateFitness(d0); // 即時更新 fitness
    });

    // 可以拖拉的程式碼
    canvas.addEventListener('drop', (e) => {
      e.preventDefault();
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }

      if (!d) return;

      const x = e.offsetX;
      const y = e.offsetY;

      const col = Math.round((x - 60) / 60);
      if (col < 0 || col >= d0.circuit[0].length) return;
      
      const row = Math.round((y - 50) / 50);
      if (row < 0 || row >= d0.circuit.length) return;

      const g = parseInt(draggedGate);

      // 清除原有 CNOT 結構（若存在）
      //if ((d.q0[col] === 5 && d.q1[col] === 4) || (d.q0[col] === 4 && d.q1[col] === 5)) {
      //  d.q0[col] = 0;
      //  d.q1[col] = 0;
      //}

      //if (g === 5) {
        // CNOT: determine control and target
      //  if (y < 75) {
      //    d.q0[col] = 4; // control
      //    d.q1[col] = 5; // target
      //  } else {
      //    d.q0[col] = 5; // target
      //    d.q1[col] = 4; // control
      //  }
      //} else {
      //  if (y < 75) {
      //    d.q0[col] = g;
          // 若另一 qubit 是 CNOT 的一部分，清除
      //    if (d.q1[col] === 4 || d.q1[col] === 5) d.q1[col] = 0;
      //  } else {
      //    d.q1[col] = g;
      //    if (d.q0[col] === 4 || d.q0[col] === 5) d.q0[col] = 0;
      //  }
      //}
      if (d0.circuit[row][col] === 4 || d0.circuit[row][col] === 5 || g === 4 || g === 5)
      { 
        let ctrl_ = -1;
        let not_ = -1;
        for (let i = 0; i < d0.circuit.length; i++)
        {
          if (d0.circuit[i][col] === 5)
          {
            ctrl_ = i;
          }
          else if (d0.circuit[i][col] === 4)
          {
            not_ = i;
          }
        }
        if (ctrl_ !== -1 && not_ !== -1)
        {
          d0.circuit[ctrl_][col] = 0;
          d0.circuit[not_][col] = 0;
        }
      }
      d0.circuit[row][col] = g;

      let had_ctrl_not = 0;
      if (g === 4 || g === 5)
      {
        for (let i = 0; i < d0.circuit.length; i++)
        {
          if ((d0.circuit[i][col] === 4 || d0.circuit[i][col] === 5) && i !== row)
          {
            had_ctrl_not = 1;
          }
        }
        //console.log(had_ctrl_not);
      }

      if (g === 4 && had_ctrl_not === 0)
      {
        //console.log("not");
        if (row !== (d0.circuit.length - 1))
        {
          if (d0.circuit[row + 1][col] === 0)
          {
            d0.circuit[row + 1][col] = 5;
          }
        }
        else
        {
          if (d0.circuit[row - 1][col] === 0)
          {
            d0.circuit[row - 1][col] = 5;
          }
        }
      }
      else if (g === 5 && had_ctrl_not === 0)
      {
        //console.log("ctrl");
        if (row !== (d0.circuit.length - 1))
        {
          if (d0.circuit[row + 1][col] === 0)
          {
            d0.circuit[row + 1][col] = 4;
          }
        }
        else
        {
          if (d0.circuit[row - 1][col] === 0)
          {
            d0.circuit[row - 1][col] = 4;
          }
        }
      }
      //console.log(d0.circuit);

      renderCircuit(0);
      updateFitness(d0); // 即時更新 fitness
    });

    // 宣告變數來記錄滑鼠位置
    let mouseDownPos = null;
    let mouseUpPos = null;

    // 監聽 mousedown 事件
    canvas.addEventListener("mousedown", (e) => {
      e.preventDefault();

      mouseDownPos = {
        x: e.offsetX,
        y: e.offsetY
      };
      //console.log("Mouse Down at:", mouseDownPos);
      //console.log("Mouse Up at:", mouseUpPos.x);
      //console.log("Mouse Up at:", mouseUpPos.y);
    });

    // 監聽 mouseup 事件
    canvas.addEventListener("mouseup", (e) => {
      e.preventDefault();
      const gen = parseInt(document.getElementById('genSlider').value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      if (d0_gen !== gen)
      {
        d0.circuit = JSON.parse(JSON.stringify(d.circuit));
        d0.fitness = JSON.parse(JSON.stringify(d.fitness));
        d0_gen = gen;
      }

      if (!d) return;

      mouseUpPos = {
        x: e.offsetX,
        y: e.offsetY
      };
      //console.log("Mouse Up at:", mouseUpPos);
      //console.log("Mouse Up at:", mouseUpPos.x);
      //console.log("Mouse Up at:", mouseUpPos.y);
      
      const col_start = Math.round((mouseDownPos.x - 60) / 60);
      if (col_start < 0 || col_start >= d0.circuit[0].length) return;
      
      const row_start = Math.round((mouseDownPos.y - 50) / 50);
      if (row_start < 0 || row_start >= d0.circuit.length) return;

      const col_end = Math.round((mouseUpPos.x - 60) / 60);
      if (col_end < 0 || col_end >= d0.circuit[0].length) return;
      
      const row_end = Math.round((mouseUpPos.y - 50) / 50);
      if (row_end < 0 || row_end >= d0.circuit.length) return;

      //console.log("start :", row_start, col_start);
      //console.log("end :", row_end, col_end);

      if (col_start !== col_end || row_start !== row_end)
      {
        //console.log("do");
        if ((d0.circuit[row_start][col_start] === 4 || d0.circuit[row_start][col_start] === 5) && col_start !== col_end)
        {
          for (let i = 0; i < d0.circuit.length; i++)
          {
            if (d0.circuit[i][col_end] === 4 || d0.circuit[i][col_end] === 5)
            {
              d0.circuit[i][col_end] = 0;
            }
          }
        }
        let row_start_ = -1;
        if (d0.circuit[row_start][col_start] === 4 || d0.circuit[row_start][col_start] === 5)
        {
          for (let i = 0; i < d0.circuit.length; i++)
          {
            if ((d0.circuit[i][col_start] === 4 || d0.circuit[i][col_start] === 5) && i !== row_start)
            {
              row_start_ = i;
            }
          }
        }
        if (row_start_ !== -1 && (row_start_ + (row_end - row_start)) >= 0 && (row_start_ + (row_end - row_start)) <= (d0.circuit.length - 1)  && col_start !== col_end)
        {
          d0.circuit[row_start_ + (row_end - row_start)][col_end] = d0.circuit[row_start_][col_start];
          d0.circuit[row_start_][col_start] = 0;
          d0.circuit[row_end][col_end] = d0.circuit[row_start][col_start];
          d0.circuit[row_start][col_start] = 0;
        }
        else if (col_start === col_end && (d0.circuit[row_start][col_start] === 4 || d0.circuit[row_start][col_start] === 5) && (d0.circuit[row_end][col_end] === 4 || d0.circuit[row_end][col_end] === 5))
        {
          let flash = d0.circuit[row_start][col_start];
          d0.circuit[row_start][col_start] = d0.circuit[row_end][col_end];
          d0.circuit[row_end][col_end] = flash;
        }
        else
        {
          d0.circuit[row_end][col_end] = d0.circuit[row_start][col_start];
          d0.circuit[row_start][col_start] = 0;
        }
        renderCircuit(0);
        updateFitness(d0); // 即時更新 fitness
      }
    });

    function drawGate(x, y, label, type) {
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      if (type === 'H') {
        ctx.fillStyle = '#f88';
        ctx.fillRect(x - 15, y - 15, 30, 30);
        ctx.strokeRect(x - 15, y - 15, 30, 30);
      } else if (type === 'T' || type === 'T†') {
        ctx.fillStyle = (type === 'T') ? '#88f' : '#4cf';
        ctx.fillRect(x - 15, y - 15, 30, 30);
        ctx.strokeRect(x - 15, y - 15, 30, 30);
      } else if (type === 'X') {
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y - 8);
        ctx.lineTo(x, y + 8);
        ctx.moveTo(x - 8, y);
        ctx.lineTo(x + 8, y);
        ctx.stroke();
      } else if (type === 'C') {
        ctx.fillStyle = '#00f';
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
      } else if (type === 'X_') {
        ctx.globalAlpha = 0.5;   // 設定透明度 0.5
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y - 8);
        ctx.lineTo(x, y + 8);
        ctx.moveTo(x - 8, y);
        ctx.lineTo(x + 8, y);
        ctx.stroke();
        ctx.globalAlpha = 1.0; // ⭐ 還原透明度
      } else if (type === 'C_') {
        ctx.globalAlpha = 0.5;   // 設定透明度 0.5
        ctx.fillStyle = '#00f';
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        ctx.globalAlpha = 1.0; // ⭐ 還原透明度
      }

      if (['H', 'T', 'T†'].includes(type)) {
        ctx.fillStyle = '#000';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x, y);
      }
    }

    function updateFitness(d) {
      // ⬇️ 使用 deferred gate 符號運算版本
      const deferredMat = checkerDeferred(d.circuit); // 回傳 DeferredMatrix

      // ⬇️ 將 DeferredMatrix 轉換為數值矩陣（complex[][]）
      const size = deferredMat.length;
      const mat = math.matrix(
        deferredMat.map(row => row.map(cell => cell.evaluate()))
      );
      
      // ✅ 顯示矩陣
      updateMatrixDisplay(mat);
      if(screenshot_ === true)
      {
        captureAndCrop();
      }

      const prod = math.multiply(math.conj(math.transpose(mat)), TargetArrat);
      const num = math.abs(math.trace(prod));
      const dem = prod.size()[0];
      const fitness = 1 - num / dem;
      document.getElementById('fitnessValue').innerText = fitness.toFixed(53);
    }

    function updateArray(d) {
      // ✅ 使用符號矩陣方式計算整個電路
      const deferredMat = checkerDeferred(d.circuit); // 回傳 DeferredMatrix

      // ✅ 將 DeferredMatrix 轉為 math.js 的複數矩陣格式（evaluate）
      const mat = math.matrix(
        deferredMat.map(row => row.map(cell => cell.evaluate()))
      );

      updateMatrixDisplay(mat);  // 顯示矩陣
      if (screenshot_ === true) {
        captureAndCrop();
      }
    }

    function renderCircuit(gen) {
      //const d = data.find(item => item.gen === gen);
      let d;
      if (gen === 0)
      {
        d = data0.find(item => item.gen === 1);
      }
      else
      {
        d = data.find(item => item.gen === gen);
        // ⭐ 動態更新 canvas 寬度（每個 gate 寬度 60px，加上起始邊界）
        const newWidth = 60 + 60 * d.circuit[0].length;  // startX + stepX * depth
        canvas.width = newWidth;
      }

      if (!d) return;

      document.getElementById('fitnessValue').innerText = d.fitness.toFixed(53);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const startX = 60;
      const stepX = 60;
      //const q0Y = 50;
      //const q1Y = 100;
      let qY = [];

      ctx.strokeStyle = '#bbb';
      ctx.lineWidth = 2;
      ctx.beginPath();

      //ctx.moveTo(startX - 40, q0Y);
      //ctx.lineTo(startX + d.q0.length * stepX, q0Y);
      //ctx.moveTo(startX - 40, q1Y);
      //ctx.lineTo(startX + d.q1.length * stepX, q1Y);
      for (let i = 0; i < d.circuit.length; i++)
      {
        qY.push((i + 1) * 50);
        ctx.moveTo(startX - 40, qY[i]);
        ctx.lineTo(startX + d.circuit[0].length * stepX, qY[i]);
      };

      ctx.stroke();

      for (let i = 0; i < d.circuit[0].length; i++) {
        const x = startX + i * stepX;
        let ctrl_ = -1;
        let not_ = -1;
        for (let j = 0; j < d.circuit.length; j++) {
          if(gateMap[d.circuit[j][i]] === "C")
          {
            ctrl_ = j;
            drawGate(x, qY[ctrl_], '', 'C_');
          }
          else if(gateMap[d.circuit[j][i]] === "X")
          {
            not_ = j;
            drawGate(x, qY[not_], '', 'X_');
          }
          else if(gateMap[d.circuit[j][i]] !== 'empty')
          {
            drawGate(x, qY[j], gateMap[d.circuit[j][i]], gateMap[d.circuit[j][i]]);
          }
        }
        if(ctrl_ !== -1 && not_ !== -1)
        {
          drawGate(x, qY[not_], '', 'X');
          drawGate(x, qY[ctrl_], '', 'C');
          ctx.beginPath();
          ctx.moveTo(x, qY[not_]);
          ctx.lineTo(x, qY[ctrl_]);
          ctx.stroke();
        }
      }

      const gen_ = parseInt(document.getElementById('genSlider').value);
      const d_ = data.find(item => item.gen === gen_);
      updateArray(d_);
      
      let str_ = "";
      for (let i = 0; i < d.circuit.length; i++)
      {
        for (let j = 0; j < d.circuit[i].length; j++)
        {
          str_ += d.circuit[i][j];
          if (j !== d.circuit[i].length - 1)
          {
            str_ += " ";
          }
        }
        if (i !== d.circuit.length - 1)
        {
          str_ += "\n";
        }
      }
      document.getElementById("circuit_n").textContent = str_;
    }

    function updateFitnessChart() {
      const genValues = data.map(d => d.gen);
      const fitnessValues = data.map(d => d.fitness);
      const maxGen = Math.max(...genValues);

      const trace = {
        x: genValues,
        y: fitnessValues,
        mode: 'lines+markers',
        type: 'scatter',
        line: { color: 'rgb(0,123,255)', width: 2 },
        marker: { size: 4, color: 'rgb(0,123,255)' },
        name: 'Fitness',
        hovertemplate: 'Generation %{x:.0f}<br>Fitness %{y:.53f}<extra></extra>'
      };

      const layout = {
        title: 'Fitness over Generations',
        xaxis: {
          title: 'Generation',
          tickfont: { size: 10 },
          titlefont: { size: 12 },
          range: [0, maxGen],            // 初始顯示範圍
          rangemode: 'nonnegative',       // 禁止負軸
          tickformat: 'd',       // <-- 這行禁用 k/M 縮寫
        },
        yaxis: {
          title: 'Fitness',
          tickfont: { size: 10 },
          titlefont: { size: 12 },
          range: [0, 1],          // <-- 固定 y 軸為 0 ~ 1
        },
        margin: { l: 50, r: 30, t: 40, b: 50 },
        height: 300, // 可自行調整
        dragmode: 'zoom' // 滑鼠框選縮放，右上角按鈕支援 pan/zoom
      };

      Plotly.newPlot('fitnessChart', [trace], layout, { responsive: true });
    }

    function jumpToGeneration() {
      const input = document.getElementById('genInput');
      const slider = document.getElementById('genSlider');
      const max = parseInt(slider.max);
      const min = parseInt(slider.min);
      const value = parseInt(input.value);
      d0_gen = 0;

      if (!isNaN(value) && value >= min && value <= max) {
        slider.value = value;
        slider.dispatchEvent(new Event('input'));
      } else {
        alert(`Please enter a number between ${min} and ${max}`);
      }
    }
  
    function identityDeferred(n) {
      const size = 1 << n;
      const I = Array(size).fill(0).map(() =>
        Array(size).fill().map(() => new DeferredCpx())
      );
      for (let i = 0; i < size; i++) {
        I[i][i] = new DeferredCpx(math.complex(1, 0), false);
      }
      return I;
    }

    function kronDeferred(A, B) {
      const r1 = A.length, c1 = A[0].length;
      const r2 = B.length, c2 = B[0].length;
      const result = Array(r1 * r2).fill(0).map(() =>
        Array(c1 * c2).fill().map(() => new DeferredCpx())
      );
      for (let i = 0; i < r1; i++)
        for (let j = 0; j < c1; j++)
          for (let k = 0; k < r2; k++)
            for (let l = 0; l < c2; l++)
              result[i * r2 + k][j * c2 + l] = A[i][j].multiply(B[k][l]);
      return result;
    }

    function matmulDeferred(A, B) {
      const n = A.length, m = B[0].length, p = A[0].length;
      const result = Array(n).fill(0).map(() =>
        Array(m).fill().map(() => new DeferredCpx())
      );
      for (let i = 0; i < n; i++)
        for (let k = 0; k < p; k++)
          for (let j = 0; j < m; j++)
            result[i][j] = result[i][j].add(A[i][k].multiply(B[k][j]));
      return result;
    }
  
    function getDeferredGate(id) {
      const I = [
        [new DeferredCpx(math.complex(1, 0)), new DeferredCpx()],
        [new DeferredCpx(), new DeferredCpx(math.complex(1, 0))]
      ];
      if (id === 0) return I;

      if (id === 1) return [
        [new DeferredCpx(math.complex(1, 0), true), new DeferredCpx(math.complex(1, 0), true)],
        [new DeferredCpx(math.complex(1, 0), true), new DeferredCpx(math.complex(-1, 0), true)]
      ];

      if (id === 2) return [
        [new DeferredCpx(math.complex(1, 0)), new DeferredCpx()],
        [new DeferredCpx(), new DeferredCpx(math.complex(1, 1), true)]
      ];

      if (id === 3) return [
        [new DeferredCpx(math.complex(1, 0)), new DeferredCpx()],
        [new DeferredCpx(), new DeferredCpx(math.complex(1, -1), true)]
      ];

      throw new Error("Unknown gate id: " + id);
    }
  
    function apply_single_qubit_gate_js(target, gate, total_bits) {
      let result = (target === 0) ? gate : getDeferredGate(0); // I
      for (let i = 1; i < total_bits; i++) {
        const g = (i === target) ? gate : getDeferredGate(0);
        result = kronDeferred(result, g);
      }
      return result;
    }
  
    function apply_cnot_js(control, target, total_bits) {
      const dim = 1 << total_bits;
      const mat = Array(dim).fill().map(() =>
        Array(dim).fill().map(() => new DeferredCpx())
      );

      for (let i = 0; i < dim; i++) {
        const b_ctrl = (i >> (total_bits - 1 - control)) & 1;
        const flip = (b_ctrl) ? (i ^ (1 << (total_bits - 1 - target))) : i;
        mat[flip][i] = new DeferredCpx(math.complex(1, 0));
      }

      return mat;
    }
  
    function applyManualCircuit() {
      const input = document.getElementById("manualCircuitInput").value.trim();
      if (!input) return alert("請輸入電路內容");

      const gen = parseInt(document.getElementById("genSlider").value);
      const d = data.find(item => item.gen === gen);
      const d0 = data0.find(item => item.gen === 1);
      d0_gen = gen;
      if (!d) return alert("無對應 generation");

      let newCircuit = [];

      // ✅ 格式 B: 偵測是否為 [ ... ] [ ... ] 格式
      if (input.includes("[") && input.includes("]")) {
        const matches = [...input.matchAll(/\[([^\]]+)\]/g)];
        if (matches.length !== d.circuit.length) {
          return alert(`括號數量 (${matches.length}) 不符合 qubit 數 (${d.circuit.length})`);
        }

        for (let i = 0; i < matches.length; i++) {
          const rowStr = matches[i][1];
          const row = rowStr.trim().split(/\s+/).map(Number);
          newCircuit.push(row);
        }
      }
      // ✅ 格式 A: 每行一個 qubit
      else {
        const lines = input.split('\n').map(line => line.trim()).filter(line => line !== "");
        for (let i = 0; i < lines.length; i++) {
          const row = lines[i].split(/\s+/).map(Number);
          newCircuit.push(row);
        }
      }

      // ✅ 根據 newCircuit 調整 d0 circuit 深度與 qubit 數
      const newQubitCount = newCircuit.length;
      const newDepth = Math.max(...newCircuit.map(row => row.length));

      // 調整 d0 circuit 結構為 newQubitCount x newDepth
      d0.circuit = Array.from({ length: newQubitCount }, (_, q) => {
        const row = newCircuit[q] || [];
        while (row.length < newDepth) row.push(0); // 補齊深度
        return row;
      });

      // ✅ 套用電路並重新 render
      document.getElementById("circuitDepth").value = newDepth;
      const canvas = document.getElementById("circuitCanvas");
      canvas.width = 60 + 60 * newDepth;
      canvas.height = 50 * newQubitCount + 50;

      renderCircuit(0);
      updateFitness(d0);
    }

    function captureMatrix() {
      const target = document.getElementById('matrix');
      html2canvas(target).then(canvas => {
        const link = document.createElement('a');
        link.download = 'matrix_snapshot.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      });
    }
  </script>


</body></html>